# 数据库

# SQL分组

group by将查询结果按照一个或多个值分组，然后对每个分组进行聚合计算，如SUM

，AVG，COUNT，也可以使用HAVING过滤分组结果。

# SQL连接

在两个表之间建立关系。inner join，返回两个表符合连接on条件的记录。不加修饰符的join默认就是inner join。

# 如何优化慢SQL？（滴滴考过）

explain语句帮我们获取执行计划的信息，通过 EXPLAIN 的结果，可以了解到如数据表的查询顺序、数据查询操作的操作类型、哪些索引可以被命中、哪些索引实际会命中、每个数据表有多少行记录被查询等信息。

# 索引底层的数据结构了解么？Hash 索引和 B+树索引优劣分析（字节考过）

Hash 索引基于哈希表（Hash Table）。哈希表使用哈希函数将键映射到表中的一个位置，以支持快速的数据查找操作。哈希表中的每个槽（bucket）可能包含一个或多个记录，通过哈希函数计算出来的值决定了记录的位置。B+ 树是一种自平衡的树数据结构，每个节点包含多个子节点和关键字。所有数据都存储在叶节点中，内部节点仅作为路由信息。

B+ 树的特点是所有叶子节点都在同一层，并且有序。Hash索引缺点是不支持范围查询以及哈希冲突问题。B+树缺点是插入删除需要平衡操作，另外他有额外的空间占用。

# binlog格式有几种？（或者问MySQL主从复制有哪些，饿了么考过）

statement格式，每条修改数据的SQL记录在binlog中。row格式，每个数据行的变更事件记录在binlog中。以及mixed格式，两种方式混合。

# 有哪些常⻅的 SQL 优化⼿段？（帆软考过）

避免使用select*，深度分页优化，避免超过3个表做join，不要用外键和级联，用union all代替union，show profiles和show profile命令查看执行时间。优化慢sql，通过set global show slow query log开启慢查询日志，然后用explain 分析对应的select语句，比较重要的字段有select type，指的是查询的类型，比如simple没有联合查询和子查询，table字段表示涉及到的表，**type**是**慢查询重要参考指标**，all，index，range，ref，eq_ref，const，System逐渐从差到好。最后是正确使用索引，被频繁更新的字段应慎重建立索引，尽量联合索引而不是单列索引。

# MySQL 的隔离级别是基于锁实现的吗？

是的，隔离级别是基于锁和mvcc实现的，读未提交没使用锁，读已提交使用共享锁读取已提交数据，可重复读使用mvcc实现，可串行化对读使用共享锁，对写使用排他锁。

# InnoDB 对 MVCC 的具体实现

通过隐藏列，undolog，读视图实现mvcc。隐藏列包含db_trx_id表示最近修改该行的事务id等，undolog保存事务修改之前数据的版本。读视图使得事务只能看到最近修改事务id小于他的行。

# char 和 varchar 的区别是什么？

char固定长度，如char10不管存的是什么都是10个字符空间，varchar可变长度，如varchar10，如果存储abc，只用3个字符空间。

# varchar(100)和 varchar(10)的区别是什么？

区别在于它们所能存储的最大字符数。VARCHAR(100) 能存储最多 100 个字符，而 VARCHAR(10) 只能存储最多 10 个字符。

# decimal 和 float/double 的区别是什么？存储钱应该⽤哪⼀种？

float 和 double 是浮点数，适合需要处理非常大或非常小的数值的场景，但它们可能会有舍入误差。decimal 是定点数，可以提供精确的十进制表示，适合需要精确计算的场景。存储钱应该使用decimal。

# 为什么不推荐使⽤ text 和 blob？

TEXT 和 BLOB 类型字段的大小可能非常大，导致索引性能下降。MySQL允许对这些字段建立全文索引，但由于字段内容的体积，建立和维护这些索引的开销较大。

# 为什么索引能提⾼查询速度?

索引可以减少磁盘I/O操作，因为它只要读取索引部分而不是整个数据表，**全表扫描非常耗时**。另外，索引可以加速排序操作order by子句，因为索引本身是排序好的数据结构。

# 聚集索引和⾮聚集索引的区别？⾮聚集索引⼀定回表查询吗?

聚集索引即索引结构和数据一起存放的索引。主键索引属于聚集索引。非聚集索引即索引结构和数据分开存放的索引。不一定，是否需要回表查询取决于索引是否覆盖了查询中所需的所有列。

# 索引这么多优点，为什么不对表中的每⼀个列创建⼀个索引呢？(使⽤索引⼀定能提⾼查询性能吗?)

索引并不都是好的，创建索引和维护索引也需要耗费资源和时间。

# B+树做索引⽐红⿊树好在哪⾥？

所有节点都在底下一层，支持范围查询，节点容量大。

# 最左前缀匹配原则了解么？

在 MySQL 建立联合索引时会遵守最左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。

# 什么是覆盖索引

覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了，而无需回表查询。

# 如何查看某条 SQL 语句是否⽤到了索引？

EXPLAIN关键字分析SQL语句，返回的key列展示了查询使用的索引。

# 哪些操作会加表级锁？哪些操作会加⾏级锁？请简单举例说⼀下

alter table会加表级锁，update以及for update会加行级锁。

# MySQL 如何使⽤乐观锁和悲观锁？

乐观锁，可以用version版本字段，在update时检查版本号是否匹配，匹配则增加版本号。悲观锁，使用select for update加行级锁。

# 慢查询⽇志有什么⽤？

慢查询日志记录了执行时间超过 long_query_time（默认是 10秒）的所有查询，在我们解决 SQL 慢查询（SQL 执行时间过长）问题的时候经常会用到。

# 如何查询当前慢查询的个数？

有个变量专门记录，show global status like ‘%Slow_queries%’，即slow queries这个变量。

# 讲一讲慢查询怎么处理？
  识别慢查询
通过慢查询日志查看具体的SQL语句，了解哪些查询耗时长。
  分析慢查询原因
常见原因，索引缺失，查询条件不合理，数据量过大，可以用explain命令分析SQL执行计划，看看是否走了索引以及是否存在全盘扫描。
  优化慢查询
添加合适索引，或者优化查询条件。

# binlog 主要记录了什么？

主要记录了 MySQL 数据库中数据的所有变化(数据库执行的所有 DDL 和 DML 语句)。

# binlog刷盘时机怎么选择？

事务在执行过程中，先把日志写入binlog cache中，只有事务提交时，才把binlog cache持久化到磁盘上的binlog文件中。默认每次提交事务的时候将binlog写入磁盘。

# 什么情况会重新生成binlog？

MySQL重启或停止，或者使用flush logs命令，或者binlog文件超过max_log_size后。

# redo log 如何保证事务的持久性？

InnoDB以页为单位管理存储空间，往MySQL插入的数据存在于页中的。为减少磁盘开销，有一个buffer pool存在于内存中。redo log 主要做的事情就是记录页的修改，比如某个页面某个偏移量处修改了几个字节的值以及具体被修改的内容是什么。在事务提交时，我们会将 redo log 按照刷盘策略刷到磁盘上去，这样即使 MySQL 宕机了，重启之后也能恢复未能写入磁盘的数据，从而保证事务的持久性。

# redolog什么情况会出现丢失数据？

如redolog写入log buffer但未写入page cache，page cache是文件系统缓存，此时db崩溃，就会出现数据丢失。

# ⻚修改之后为什么不直接刷盘呢？

性能非常差！InnoDB 页的大小一般为 16KB，而页又是磁盘和内存交互的基本单位。这就导致即使我们只修改了页中的几个字节数据，一次刷盘操作也需要将 16KB 大小的页整个都刷新到磁盘中。而且，这些修改的页可能并不相邻，也就是说这还是随机 IO。

# binlog 和 redolog 有什么区别？

binlog用于数据库还原，属于数据级别的数据恢复，主从复制是binlog的应用场景。redolog属于事务级别的数据恢复。**redolog**是**InnoDB引擎特有**的，binlog是所有存储引擎共有的，binlog是MySQL的server层实现的。redolog是物理日志，记录的是某个页的修改。binlog属于逻辑日志，记录的是数据库执行的所有DDL和DML语句。

# undo log 如何保证事务的原⼦性？

每一个事务对数据的修改都会被记录到 undo log ，事务中的操作如插入更新删除，对应的逆操作都记录在undo log中。undolog的信息也会被记录在redolog中，保证持久性。对于undolog的清理，如果是insert操作的undolog，在事务提交后立即删除，如果是update或delete操作的undolog，不会被立即删除，这些log被添加到history list中，等待purge线程处理。undolog的存储结构是段式，每个undo操作占用一个undolog segment。

# 除了保障事务原子性，undolog还有什么用？

mvcc的实现依赖于undolog和read view，如果数据行不可见，则通过这一行的指针找到undolog的历史版本。

# 能⽤ MySQL 直接存储⽂件（⽐如图⽚）吗？

可以但是存在性能问题，使用blob存储二进制数据。

# MySQL 如何存储 IP 地址？

用字符串varchar占空间，MySQL用Inet aton把IP地址转为无符号整数，inet ntoa把整数转化为IP地址。

# 如何分析 SQL 的性能？

EXPLAIN 是分析查询语句性能的最重要工具之一，可以判断查询是否使用了合适的索引，是否存在不必要的全表扫描，以及多表查询的连接顺序是否合理。通过配置文件或动态设置可以启用慢查询日志，SET GLOBAL slow_query_log = 'ON'。

# 简单说⼀下⼤表优化的思路

合理设计索引，针对经常使用在where，join，order by和group by的列建立索引。采用分区表，如将大表按照日期，ID范围分区 ，减少扫描范围。以及采用分库分表方法，将数据按业务规则分散到多个表或库中，减少单个表的压力。

# 为什么单表数据量过大会查找效率变慢？为什么磁盘查找会变高？

  1. 单表数据量大的影响

-**数据量增加**：随着单表数据量的增加，数据库需要处理的数据量也会随之增加。
-**索引效率下降**：索引是为了加速查询而存在的，但当数据量过大时，索引的维护成本会变高，查询效率会下降。

  2. 查找效率变慢的原因

-**索引失效**：当数据量过大时，索引可能无法完全加载到内存中，导致索引失效，查询需要进行全表扫描。
-**磁盘I/O增加**：全表扫描意味着需要从磁盘读取大量数据，磁盘I/O操作的次数和时间都会增加，导致查询效率变慢。

  3. 磁盘查找变高的原因

-**磁盘碎片**：随着数据量的增加，磁盘碎片也会增加，进一步增加了磁盘查找的时间。

# 读写分离如何实现？

使用MySQL内置的主从复制机制，将主库的变更复制到从库。首先在主库上通过log-bin配置文件启用二进制日志，然后再从库上通过relay-log配置启用复制，最后在从库上执行Change master to 命令指向从库。

# 为什么要分库分表？有哪些常⻅的分库分表⼯具？

首先要提升性能，减少单表数据量。然后提高可拓展性，实现更高的并发，最后是提高可用性，即使某个库出现问题，也只会影响部分业务。常用的分库分表工具有MyCat，基于阿里的Cobar架构。以及shardingsphere，Apache的开源分布式db中间件。

# 深度分⻚如何优化？

深度分页指的是当查询结果集非常庞大时，用户请求的是结果集的某个较深的页面（例如，第1000页）。优化方案，如范围查询，子查询，延迟关联和覆盖索引。

当保证id连续时，根据id范围分页。子查询，先查出limit第一个参数对应的主键值，再根据主键值过滤并limit，会产生一张新表，只适用于id正序。延迟关联，也是把条件转移到主键索引树，和子查询一样，不过用join实现。覆盖索引，把要查询的列建立覆盖索引，避免InnoDB回表操作。

# 数据冷热分离如何做？

冷热数据的识别，如几年前的日志、过期订单或者访问量低的数据等，当做冷数据。数据库设计，热表存储近期的数据，冷表存储历史数据。冷数据的迁移，可以用xxl-job分布式调度平台定时扫描数据库，找出冷数据，批量复制到冷库，然后从热库中删除。或者从binlog中提取满足冷数据条件的数据，然后复制到冷库，从热库删除。

# redis

# Redis 为什么这么快？（滴滴考过）

首先Redis 的大部分操作都在内存中完成，并且采用了高效的数据结构，因此 Redis 瓶颈可能是机器的内存或者网络带宽，而并非 CPU。其次Redis 采用单线程模型可以避免了多线程之间的竞争，省去了多线程切换带来的时间和性能上的开销。最后，Redis 采用了 I/O 多路复用机制处理大量的客户端 Socket 请求，IO 多路复用机制是指一个线程处理多个 IO 流，就是我们经常听到的 select/epoll 机制。简单来说，在 Redis 只运行单线程的情况下，该机制允许内核中，同时存在多个监听 Socket 和已连接 Socket。

# 缓存穿透和缓存击穿有什么区别？缓存雪崩和缓存击穿有什么区别？（滴滴考过）

缓存穿透是，当用户访问的数据，既不在缓存中，也不在数据库中，导致请求在访问缓存时，发现缓存缺失，再去访问数据库时，数据库中也没有要访问发现的数据。缓存击穿是，如果缓存中的某个热点数据过期了，此时大量的请求访问了该热点数据，就无法从缓存中读取，直接访问数据库。缓存雪崩是，大量的用户请求，都无法在 Redis 中处理，于是全部请求都直接访问数据库，从而导致数据库的压力骤增，严重的会造成数据库宕机，从而形成一系列连锁反应，造成整个系统崩溃。

# redis的主从复制有哪两个？（饿了么考过）

redis的主从复制有同步复制和异步复制两种。同步复制通过引入redis

# 设计一个抖音视频热度排行榜，假设存量两百亿，日增量一千万？

使用zset，将视频id作为元素，视频的热度作为分数，可以实时更新排行榜。但是，如果日增量非常大如1000万，直接添加到zset可能导致性能问题，因为zset的插入复杂度是O log n。

  **流量压力**的考虑
为了应对这种情况，可以考虑以下几种优化方案：
  1.**分片**：将**ZSET**分片到多个Redis实例上，每个实例负责一部分数据。这样可以分散流量压力。
  2.**批量处理**：将日增量数据先缓存起来，然后批量插入到**ZSET**中，减少单次插入的次数。
  3.**增量更新**：只更新发生变化的视频热度，而不是全量更新。这样可以减少不必要的操作。


# Redis几种数据类型怎么实现的？

reids有五种数据类型，String List Hash Set Zset。String的实现是基于SDS的，拼接字符串不会造成缓冲区溢出。List基于**quicklist**实现，quicklist是双层结构，内部有多个node，每个node是一个ziplist或者linkedlist。hash基于listpack或哈希表实现。set基于整数集合或哈希表实现。zset基于listpack或跳表实现。

# zset的时间复杂度是什么？

zset如果元素比较多，那么用跳表实现，跳表的增删查的时间复杂度都是O log n，但是最坏情况下是o n，这时没有建立有效的索引。

# 本地缓存和分布式缓存有什么区别？如何选择？

本地缓存存储在本地应用程序或服务器内存中。而redis存储在分布式缓存系统多个 节点上。当数据量小，对实时性要求高时选用本地缓存，数据量较大，需要高并发选择redis缓存。

# 本地缓存有哪些缺点？

本地缓存和应用耦合，对分布式架构不友好。

# 什么是多级缓存?为什么要用？

多级缓存是本地缓存+分布式缓存的多级缓存方案。使用的原因是本地缓存的访问速度远大于分布式缓存。

# 多级缓存一致性怎么保证？

保证最终一致性。采用消息队列保证一个实例的本地缓存变化后，其他实例能及时更新他们的本地缓存。

# 常见的缓存更新策略有哪些？

旁路缓存模式。写先更新db然后直接**删除cache**。读从cache读取数据读到直接返回,没有则找db，再把db 数据放到cache中。读写穿透模式。写先查cache，cache不存在直接更新db，若cache存在则先更新cache然后cache自己更新db。读，从cache读取数据，读到就返回，读不到先从db读，写入cache后返回。异步缓存写入模式，和读写穿透模式差不多，不过在写的时候如果cache存在则先更新cache，然后异步更新db 。

写db后删除cache是因为cache存放的数据要服务端进行大量计算才能得出，如果频繁修改db，就会导致经常更新cache，而cache可能都没有被访问过。

旁路缓存模式的缺陷有首次请求数据一定不在cache的问题，通过热点数据提前放入cache解决。另外是写频繁导致cache数据频繁删除，影响缓存命中率。如果是强一致性场景，则更新db时同步更新cache，不过要加一个分布式锁保证更新cache时候不存在线程安全问题。如果cache删除失败，隔一段时间重试，设置重试次数，达重试次数还没成功，则把这个失败的key放到队列中，等这个cache能用后，在把key删除。

# 什么是 Redis Module？有什么⽤？项⽬使⽤过吗？

Redis Module 是 Redis 4.0 引入的一项功能，允许开发者通过插件的方式扩展 Redis 的核心功能。用处，module可以拓展数据结构和命令，如布隆过滤器，图等数据结构。常见的Redis module有redisearch，redisjson。

# 如何基于 Redis 实现分布式锁？

redis的setnx可以实现分布式锁的互斥性，如果key存在，set不会成功，返回0。释放锁使用del直接删除key。可以通过设置过期时间防止锁死，如set suo 1 ex 3 nx，3秒删除。结合看门狗机制，如renewExpirationAsync方法实现续期。nx是not exist的缩写，ex是expire的缩写。

# Redis 可以做搜索引擎么？

可以，采用rediseasrch，可以在redis上实现全文搜索，模糊匹配，排序，过滤等功能。

# Redis 为什么⽤跳表，⽽不⽤平衡树、红⿊树或者B+树？

首先从内存占用上来比较，跳表比平衡树更灵活一些。平衡树每个节点包含 2 个指针（分别指向左右子树），而跳表每个节点包含的指针数目平均为 1/(1-p)，因为跳表每层提升的概率是p，累加就是一个无穷级数。其次，在做范围查找的时候，跳表比平衡树操作要简单。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。而在跳表上进行范围查找就非常简单，只需要在找到小值之后，对第 1 层链表进行若干步的遍历就可以实现。最后，从算法实现难度上来比较，跳表比平衡树要简单得多。平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而跳表的插入和删除只需要修改相邻节点的指针，操作简单。

# Redis为什么使⽤ ListPack 替代 ZipList?

ziplist是一种紧凑的编码格式，用于redis的zset和hash的底层实现。在ziplist中prevlen是可变长编码，如新元素长度是超过253字节的，后续元素prevlen要从1字节拓展到5字节，这又会导致元素自身的长度增加4字节，如果他也超过了253字节，再后续的元素也要1变5.。在listpack中只记录当前节点的长度。因此解决了连锁更新的问题。

# Zset 的应⽤场景是什么？项⽬哪⾥⽤到了？

Zset 类型用于排序场景，比如排行榜、电话和姓名排序等，也可以用于实现延迟队列，延迟是指把要做的事推迟后再做，zset有score属性存储延期时间。

# **Redis 批量操作的⽅式有哪些**？

首先是，管道pipeline，它允许客户端一次性发送多个命令道redis服务器，只通过一次网络请求实现，然后一次性接受所有命令的响应。其次是multi命令，将一组命令打包成一个事务，顺序执行。然后是lua脚本，使用eval命令将lua脚本发送到redis服务器。最后是mset命令，针对多个键的批量操作命令。

# **为什么会有 Redis 内存碎⽚?如何清理 Redis 内存碎⽚**？

内存碎片可以理解为那些不可用的空闲内存。产生的原因是redis的zmalloc方法向操作系统申请的内存空间大于数据存储需要的空间，另外当redis某个数据删除时，这个空间也不会释放给操作系统。通过配置config set activedefrag yes清理内存碎片。

# **为什么会有慢查询命令**？（redis慢查询的原因是什么？）

一些命令如KEYS \*，HGETALL具有O（n）时间复杂度，会显著增加执行时间。解决办法有，避免使用时间复杂度高的命令，使用hscan，sscan，zscan命令替代。

# **缓存预热如何实现**？

有两种实现方式。

第一种，使用定时任务，比如 xxl-job，来定时触发缓存预热的逻辑，将数据库中的热点数据查询出来并存入缓存中。

第二种，使用消息队列，比如 Kafka，来异步地进行缓存预热，将数据库中的热点数据的主键或者 ID 发送到消息队列中，然后由缓存服务消费消息队列中的数据，根据主键或者 ID 查询数据库并更新缓存。

# 什么是 Sentinel？ 有什么⽤？

sentinel监控 Redis 节点的运行状态并自动实现故障转移。一个简易的sentinel集群包括，3个sentinel节点，2个slave节点，1个master节点，quorum表示判定master失效最少需要的仲裁节点数。

# Sentinel 如何检测节点是否下线？主观下线与客观下线的区别?

主观下线，节点认为某个redis节点已经下线，但不确定，需要其他节点的投票。客观下线，法定数量，通常为过半的节点认为某个redis节点已经下线，那么他就是真下线了。如果客观下线的是master，那么sentinel中会有一个leader节点负责故障转移。

# Sentinel 是如何实现故障转移的？

选出新主节点，将从节点指向新主节点，通知客户端主节点已更换，将旧主节点变为从节点。这个过程由leader节点负责，leader节点通过如raft算法实现选举。故障转移就是每个节点指针的变化。

# Sentinel 如何选择出新的 master（选举机制）?

slave必须是在线才能参加新的master选举。选举有3个维度。第一个slave优先级，配置replica-priority，手动设置。第二个是复制进度，sentinel总是希望选出与旧master数据差异最小的slave升职为新的master。第三个是运行id，万一有多个slave的优先级和复制进度一样的话，选择runid小的成为新的master。

# Sentinel 可以防⽌脑裂吗？

可以，脑裂就是网络问题，导致主从节点失去联系，从节点选出自己的主节点，等网络恢复，后选出的主节点会被降级为从节点，再进行同步复制的时候，就会丢失数据。解决方法时当发现从节点下线时，禁止主节点进行写数据，可以配置min-slave-to-write x以及min-slave-max-lag x。

# 为什么需要 Redis Cluster？解决了什么问题？有什么优势？

保障redis服务高可用。解决单节点在拓展性和可用性的限制。优势有，通过主从复制提供故障恢复能力，以及可以通过添加节点增加存储计算能力，以及数据自动分布在集群不同节点上。

# Redis Cluster 是如何分⽚的？

使用槽的概念来管理分片，整个集群分为16384个槽，每个槽包含一定范围的健，redis用crc16哈希算法将键映射到某个槽，redis用Gossip协议传播集群状态信息，如节点状态和槽分配信息。

# 为什么 Redis Cluster 的哈希槽是 16384 个?

哈希槽太大会导致心跳包太大，消耗太多带宽。

哈希槽总数越少，对存储哈希槽信息的 bitmap 压缩效果越好。

Redis Cluster 的主节点通常不会扩展太多，16384 个哈希槽已经足够用了。

# 如何确定给定 key 的应该分布到哪个哈希槽中？

首先计算key的crc16哈希值，假如结果为12345，然后计算槽编号，12345%16384，结果为4597，查找redis集群的槽到节点的映射表，找到负责4597的节点。

# Redis Cluster ⽀持重新分配哈希槽吗？

支持重新分配哈希槽，使用cluster addslots命令添加。

# Redis Cluster 扩容缩容期间可以提供服务吗？

扩缩容期间可以提供服务。提供了重定向机制。ASK 重定向:可以看做是临时重定向，后续查询仍然发送到旧节点。MOVED 重定向:可以看做是永久重定向，后续查询发送到新节点。

# Redis Cluster 中的节点是怎么进⾏通信的？

基于gossip协议通信，节点之间会发送多种gossip信息。meet信息，将一个节点添加进cluster。ping pong信息，交换节点的状态信息，疑似下线状态pfail和下线状态fail。fail信息，a节点发现b节点pfail，并在下线报告有限期内cluster内半数以上节点将b标记未pfail则a广播fail消息通知大家b节点为fail。

Java基础

# 谈谈对 Java 注解的理解，解决了什么问题？

Java 注解（Annotations）是一种元数据（metadata），用于为程序元素（如类、方法、变量、参数等）提供附加信息。注解不会直接影响程序的逻辑，但可以通过编译时或者运行时的工具进行处理，以实现如自动化配置功能。解决的问题，如减少样板代码，提高代码可读性并与框架结合。

# 注解的实现原理？

注解本质是一个**继承了Annotation**的特殊接口，其具体实现类是Java运行时生成的动态代理类。我们通过反射获取注解时，返回的是Java运行时生成的动态代理对象。通过代理对象调用自定义注解的方法，会最终调用AnnotationInvocationHandler的invoke方法。该方法会从memberValues这个Map中索引出对应的值。而memberValues的来源是Java常量池。

# Java 反射？反射有什么缺点？你是怎么理解反射的（为什么框架需要反射）？

反射是对于一个类，能知道所有属性和方法，对于一个对象，可以调用它的任意一个方法和属性。缺点，如性能开销，反射需要在运行时额外检查，比直接调用慢。需要反射，比如配置文件加载，在配置文件指定类名和方法名，用class，forname方法获得类，用class，getdeclaredmethod方法获得方法的method对象，然后用method对象调用invoke方法就实现了动态创建对象和调用方法。

# Java 泛型了解么？什么是类型擦除？介绍⼀下常⽤的通配符？

泛型是Java5引入的特性，允许类，接口和方法能操作对象的类型，实现代码的参数化类型。泛型在编译时检查类型，避免运行时ClassCastException。类型擦除，指泛型类型在编译后被擦除，在运行时不存在泛型信息，问号 是无界通配符，可以接受任意类型。问号 extends T，上界通配符，传入的类型必须是T的子类型，上界通配符只能从父类读取数据，不能添加数据。

# 内部类了解吗？匿名内部类了解吗？

定义在一个类内部的类，匿名内部类是没有名字的内部类，在使用时定义和实例化。应用场景如按钮点击事件处理器。

# BIO,NIO,AIO 有什么区别?

BIO阻塞IO，是同步阻塞的，NIO非阻塞IO是I/O多路复用模型，异步IO，基于事件和回调机制实现。并发能力逐渐更强。

# Java并发进阶

# 乐观锁和悲观锁了解么？如何实现乐观锁？（字节考过）

悲观锁，假定会发生并发冲突，在数据被访问之前加锁，适用于写频繁场景，Java中通过ReetrantLock或synchronized实现。乐观锁假设数据竞争不会发生，不会在开始加锁，而是在提交数据检查冲突，如版本号检查，若冲突则重试，适合读频繁场景。

乐观锁用版本号或者cas实现。

# cas了解吗？原理是什么？

很多地方用到了cas，比如Concurrenthashmap采用cas和Synchronized保证并发安全。cas的原理是unsafe类中的native方法compareandswapobjecct实现，它调用本地代码来做，和具体操作系统和cpu密切相关。cas存在aba问题，一个值原来是a，变成了b，又变回了a，cas是检查不出来变化的，但实际上被更新了两次，aba问题通过加上版本号或者时间戳解决。

# 线程池处理任务的流程了解吗？（讯飞考过）

提交一个任务，如果**核心线程没有满**，就创建一个线程，如果满了，就是会加入等待队列，如果**等待队列满了**，就会增加线程，如果**达到最大线程数量**，就会按照一些丢弃的策略进行处理。

# Java 内存区域和 JMM 有何区别？

Java内存区域包含五个部分，虚拟机栈，本地方法栈，程序计数器，方法区，堆。他是执行Java程序的内存布局。Java内存模型定义了多线程如何进行内存访问的规则。有主内存和工作内存的概念。主内存是共享的，工作内存是独享的。

# happens-before 原则说一下

他是一个偏序关系，如A happens before B，那么a的所有写操作在b开始之前对b可见，JMM定义了几条规则，如在一个线程内，顺序的前面的操作先于后面的操作。对一个锁的解锁先于加锁动作。对volatile变量的写操作先于读操作。

# 线程池有什么⽤？为什么不推荐使⽤内置线程池？

提高性能，线程创建和销毁开销大，线程复用可以减少开销。提高稳定性，线程池可以限制最大线程数。为什么不推荐内置的线程池，如FixedThreadPool，他用了无界队列，如果提交过快，任务会无限积压，导致OOM错误。推荐使用ThreadPoolExecutor自定义线程池，指定核心数，最大线程数，饱和策略。

# Java 线程池有哪些参数？阻塞队列有⼏种？拒绝策略有⼏种？

corePoolSize，maxPoolsize，workQueue，阻塞队列有ArrayBlockingQueue，FIFO，基于数组的有限阻塞队列。拒绝策略，AbortPolicy，抛出异常RejectedExecutionException，或者把任务回退给调用者线程，或者直接丢弃任务。

# 实现 Runnable 接⼝和 Callable 接⼝的区别

runnable适用于不需要返回值的简单后台任务，callable适用于需要返回值或抛出异常的复杂任务。

# 如何给线程池命名？为什么建议给线程池命名？

通过自定义ThreadFactory实现，在创建线程池时传入线程工厂。或者使用谷歌的ThreadFactoryBuild直接setNameFormat。因为好的命名可以方便排查问题。

# 如何动态修改线程池参数？

ThreadPoolExecutor提供了一些set方法动态调整参数，如setCorePoolSize

# AQS 原理了解么？AQS 组件有哪些？

AbstractQueueSynchronizer，是并发基础框架，使用状态管理和FIFO等待队列实现线程排队，支持独占和共享两个模式。组件有ReetrantLock等。

# Semaphore 有什么⽤？原理是什么？

semaphore是Java并发包的一个同步类，用于控制并发访问线程数量，原理基于AQS，通过许可计数器管理线程对资源的访问，它维护一个整型变量permits表示许可数量。

# CountDownLatch 有什么⽤？原理是什么？

countdownlatch是Java并发包的一个同步类，用于协调多个线程的执行顺序，它通过维护一个计数器，允许线程等待其他线程完成任务后再执行，其他线程使用countdown方法使其减一，await方法在数字变为0时会被唤醒。

# CyclicBarrier 有什么⽤？原理是什么？

cyclicbarrier适用于多线程任务需要在某个同步点上等待的场景。原理，创建时，内部维护一个计数器parties跟踪已到达屏障点的线程数，线程调用await方法时，计数器会递减，并使当前线程阻塞，等待其他线程到达await，当所有线程都到了，如果定义了barrierAction，会在这时候执行，然后所有线程继续执行。然后屏障被重置。

# 多个任务的编排可以怎么做？项⽬⽤到了 CompletableFuture 吗？

CompetableFuture可以用于任务编排。顺序执行，可以用thenApply，thenAccept，thenRun，将多个任务串联起来，lamda表达式。并行执行，用allOf和anyOf，并行执行多个任务。

# JVM（进阶）

# 垃圾回收算法有哪些?（饿了么考过）

标记-清除算法:标记-清除算法分为“标记“和“清除“两个阶段，首先通过可达性分析，标记出所有需要回收的对象，然后统一回收所有被标记的对象。

复制算法:原理是，将内存分成两块，每次申请内存时都使用其中的一块，当内存不够时，将这一块内存中所有存活的复制到另一块上。然后将然后再把已使用的内存整个清理掉。

标记-整理算法:复制算法在 GC 之后存活对象较少的情况下效率比较高，但如果存活对象比较多时会执行较多的复制操作，效率就会下降。而老年代的对象在 GC 之后的存活率就比较高，所以就有人提出了“标记-整理算法”。标记-整理算法的“标记“过程与“标记-清除算法”的标记过程一致，但标记之后不会直接清理。而是将所有存活对象都移动到内存的一端。移动结束后直接清理掉剩余部分。

分代回收算法:分代收集是将内存划分成了新生代和老年代。分配的依据是对象的生存周期，或者说经历过的 GC 次数。对象创建时，一般在新生代申请内存，当经历一次 GC 之后如果对还存活，那么对象的年龄 +1。当年龄超过一定值(默认是 15，可以通过参数 -XX:MaxTenuringThreshold 来设定)后，如果对象还存活，那么该对象会进入老年代。

# 栈中存放什么数据，堆中呢？

栈，存局部变量，方法调用信息，操作数栈，方法返回地址。堆存对象实例，数组。

# ⼤对象放在哪个内存区域？

大对象通常会被分配到堆内存区域。堆内存用于存储所有的对象实例和数组。当对象较大时，它们会在堆中分配较大的空间，并且可能会影响垃圾回收的性能。

# 对象的访问定位的两种⽅式（句柄和直接指针两种⽅式）

句柄方式：对象的引用实际上是一个指向句柄的指针，句柄本身包含了**对象的实际地址**和一些其他信息。直接指针方式：引用直接指向对象在内存中的位置。句柄相当于\**p才能获得对象实例信息，直接指针\*p即可。

# 为什么需要GC?

因为他自动管理内存，解决了内存泄漏问题，即内存中被占用但无法使用的区域，解决了内存碎片化问题，提高内存使用效率。

# 讲⼀下可达性分析算法的流程。 哪些对象可以作为 GC Roots 呢？

算法流程，定义GC Roots，确定哪些对象可以作为起点。从GC Roots开始遍历，遍历所有直接引用的对象。标记对象，将所有访问过的对象标为可达状态。回收不可达对象，进行垃圾回收。可以作为GC Root的对象，虚拟机栈的引用，包含线程栈栈帧内的引用。方法区的引用，包含类的静态字段，这些引用代表类加载过程中持有的对象。本地方法栈中的引用，如native方法中持有的引用对象。

# 如何判断对象是否死亡（引⽤计数法和可达性分析算法两种⽅法）？

引用计数法，为每个对象维护一个引用计数器，记录有多少个引用指向对象，不能处理两个对象相互引用问题。可达性分析，定义哪些对象可以作为GC Root，从Root进行dfs，不可达的对象进行回收。

# 如何判断⼀个常量是废弃常量?如何判断⼀个类是⽆⽤的类?

如果字符串常量池中的字符串（例如“abc”）没有任何 String 对象引用它，这个常量被认为是废弃常量。无用类的判断条件，如果这个类的所有实例已被回收，他就是无用类。如果加载这个类的classloader已经被回收那么他就是无用类。

# 默认的垃圾回收器是哪⼀个？ZGC 了解吗？

较新的版本（Java 9及之后），默认的垃圾回收器是G1（Garbage-First）垃圾回收器。在较早的版本中，默认的是Parallel GC。ZGC（Z Garbage Collector）是一个低延迟垃圾回收器，旨在减少GC暂停时间。

# 讲⼀下 CMS 垃圾收集器的四个步骤

初始标记，暂停应用程序执行，标记所有GC root可达对象。并发标记，CMS与应用程序并发，通过遍历对象图标记可达对象。重新标记，标记在并发标记未捕获的对象。并发清除，CMS与应用程序并发运行，清理对象。

# 并发标记要解决什么问题？并发标记带来了什么问题？如何解决并发扫描时对象消失问题？

并发标记解决GC中应用程序停顿的问题，允许GC程序和应用程序并发执行。问题有对象可能在并发标记汇总被回收，导致遗漏一些对象。解决方法有双重标记法，在并发标记前，使用初始标记创建快照，标记根对象。

# G1 垃圾收集器的步骤

初始标记，标记GC根关联对象。并发标记，与应用程序并发运行，标记所有可达对象。最终标记，标记并发标记期间变化的对象。筛选和清理，回收标记的对象。

# JVM 中的安全点和安全区各代表什么？

安全点是程序执行的特定时刻，所有线程都可以安全暂停下来进行垃圾收集。安全区是在程序执行的代码段内，GC可以安全进行，不用考虑异常问题。

# 堆内存相关的 JVM 参数有哪些？

\-Xms设置jvm堆初始内存堆大小，如-Xms512m设置为512MB，-Xmx设置堆最大大小。

# GC性能指标了解吗 ？调优原则呢？
GC性能指标关注吞吐量，停顿时间和垃圾回收效率。调优原则是降低full gc频率和减少full gc时间。

# 你在项⽬中遇到过 GC 问题吗？怎么分析和解决的？

上线后，发现接口调用频繁导致Young GC频繁告警。Young GC次数增多，同时Old区内存快速升高，最终触发了Full GC。分析发现Guava Cache的Map对象占用大量内存。问题分析：Guava Cache没有设置最大缓存数量，仅设置了过期时间。这导致缓存中存储了大量对象。解决方法，通过为Guava Cache设置最大缓存数量限制，控制缓存中对象的数量，减少内存占用。

# 如何降低 Full GC 的频率？

Full GC频繁的可能原因，调用System.gc()，或者Old区空间不足，或者永久代满。通过代码排除了前两种可能性，元空间满了，通过使用-XX:MetaspaceSize=128M指定大小。

# 项⽬中实践过 JVM 调优吗？怎么做的？

在公司投放引擎系统中每次发版启动后会进行手动预热，流量切入后，偶尔出现长达2秒的年轻代GC暂停，影响业务。通过GC日志发现每次年轻代GC都会有大量对象晋升，大概600MB。JVM的年轻代GC阶段会根据survivor区的对象总大小动态调整对象晋升年龄阈值，而在启动时，大量新对象在survivor区占据大空间，导致年龄阈值调低为1，意外的晋升到老年代。解决方法，通过调整-XX:SurvivorRatio改变Survivor区的大小，如将8改成3，使得survivor占新生代内存的40%，确保容纳大部分对象。修改JVM参数后，再次进行发版和手动预热，年轻代GC暂停花了30毫秒左右，长暂停问题得到解决。

# 网络

# DNS 解析的过程是什么样的（滴滴考过）

递归查询。当用户需要解析一个域名时，首先向本地DNS服务器发送解析请求。如果本地DNS服务器没有缓存结果，它将代表用户向更高层级服务器发起查询，这时更高层级服务器会帮本地服务器递归找到IP地址。迭代查询，也就是非递归查询。本地DNS服务器首先查询根服务器，根服务器不返回最终结果，而是告诉本地服务器查询顶级域服务器如com，顶级域名服务器再指向具体域名如example.com的权威DNS服务器，权威服务器返回最终IP地址给本地服务器，本地返回给用户。

# GET 和 POST 的区别？（字节考过）

GET用于获取查询资源。POST用于创建或修改资源。GET是幂等的而POST是不幂等的。GET请求的参数通常在URL中，而POST请求的参数通常在请求体body中，有多种编码格式，如json等。get请求时幂等的所以可以被浏览器或网关缓存，而POST不适合被缓存。get和post如果用http协议那么都不安全，因为是明文的，要用https。

# TCP 的三次握⼿与四次挥⼿的内容？ TCP 为什么连接是三次握⼿⽽断开是四次握⼿？（滴滴考过）

一次握手:客户端发送带有 SYN(SEQ=x) 标志的数据包, 发给服务端，然后客户端进入 SYN_SEND 状态，等待服务端的确认;

二次握手:服务端发送带有 SYN+ACK(SEQ=y,ACK=x+1)标志的数据包, 发给客户端,然后服务端进入SYN RECV状态:

三次握手:客户端发送带有 ACK(ACK=y+1)标志的数据包, 发给服务端，然后客户端和服务端都进入ESTABLISHED 状态，完成TCP三次握手。

第一次挥手:客户端发送一个 FIN(SEQ=x) 标志的数据包发给服务端，用来关闭客户端到服务端的数据传送。然后客户端进入 FIN-WAIT-1状态。

第二次挥手:服务端收到这个 FIN(SEQ=X)标志的数据包，它发送一个ACK(ACK=x+1)标志的数据包发给客户端 。然后服务端进入 CLOSE-WAIT 状态，客户端进入 FIN-WAIT-2 状态。第三次挥手:服务端发送一个 FIN (SEQ=y)标志的数据包发给客户端，请求关闭连接，然后服务端进入LAST-ACK 状态。

第四次挥手:客户端发送 ACK(ACK=y+1)标志的数据包发给服务端，然后客户端进入TIME-WAIT状态服务端在收到 ACK(ACK=y+1)标志的数据包后进入 CLOSE 状态。此时如果客户端等待2MSL 后依然没有收到回复，就证明服务端已正常关闭，随后客户端也可以关闭连接了。

三次握手确认client和server发送接收正常。四次挥手是因为TCP是全双工协议，client结束传输不代表server结束传输。

# 你知道粘包和拆包吗？为什么会发生？怎么解决？（字节考过）
粘包是发送方发送的多个小数据包被接收方一次性接收，导致接收方无法区分这些数据包的边界。
拆包是发送方发送的一个大数据包被接收方分成多次接受，导致接收方无法一次性获取完整数据。
为什么？tcp是流式协议，不保留消息的边界，只保证数据顺序和可靠性。
缓冲区大小，发送方和接收方的缓冲区大小不一致，可能导致数据包被拆分或合并。
nagle算法会延迟小数据包的发送，可能粘包问题。
如何解决？消息定长。发送方和接收方约定每个消息长度固定。
消息分隔符，在每个消息的末尾加上特定的分隔符，接收方根据不同分隔符区分不同的消息。

# 为什么 DNS 协议使⽤ UDP？只使⽤了 UDP 吗？

因UDP不需要TCP那样建立连接，DNS查询通常是小数据包，UDP可以显著减少延迟。但是DNS并不只使用UDP，当DNS响应数据超过512字节时，会使用TCP。

# TCP 是如何保证传输的可靠性？（⾥⾯涉及到的知识点⾮常多，每个都能挖掘不少问题，例如重传机制、流量控制、拥塞控制。如果⽬标是⼤⼚的话，⼀定要吃透，⾯试经常会问的）

首先是基于数据块的传输。数据被划分成数据块再发给网络层。然后是丢弃重复序列号的数据包。然后是TCP对首部和数据进行校验和，如果校验和有错则丢弃这个报文段。然后是重传机制，如超时重传，快速重传，快速是指看接收端的响应来进行重传。SACK在快速重传基础上，返回最近收到的报文段序列号范围。然后是流量控制，TCP client和server都有固定大小缓冲区，当client来不及处理server的数据，提示server降低速率，采用滑动窗口机制。然后是拥塞控制，发送方要保证发送的大小小于接收方的滑动窗口大小以及网络拥塞窗口的大小。

# HTTP 报⽂的内容简单说⼀下！ HTTP 请求报⽂和响应报⽂中有哪些数据？

请求报文，包含请求行，请求行包括请求方法、请求目标、和协议版本，请求头部，空行，请求体。响应报文，包含状态行，响应头部，空行，响应体。

# HTTPS 的安全性体现在什么⽅⾯？（本质还是在问 HTTPS 原理）

HTTPS 之所以能达到较高的安全性要求，就是结合了 SSL/TLS 和 TCP 协议，对通信数据进行加密，解决了 HTTP 数据透明的问题。传输的数据用对称加密算法，但对称加密的秘钥用server端的证书进行了非对称加密。

# HTTPS 加密过程是怎么样的？

1.客户端向服务器发送 HTTPS 请求,

2.服务器将公钥证书发送给客户端。

3.客户端验证服务器的证书。

4.如果验证通过，客户端生成一个用于会话的对称密钥。

5.客户端使用服务器的公钥对对称密钥进行加密，并将加密后的密钥发送给服务器6.服务器使用私钥对客户端发送的加密密钥进行解密，得到对称密钥。

7.服务器和客户端使用对称密钥进行加密和解密数据传输。

# HTTP/1.0 和 HTTP/1.1 有什么区别？

HTTP1.1采用长连接，以及缓存机制，他们的响应状态码不同，以及1.1带宽更大，host头处理不同。

# HTTP/1.1 和 HTTP/2.0 有什么区别？

2.0采用I/O多路复用，以及二进制帧，头部压缩。

# HTTP/2.0 和 HTTP/3.0 有什么区别？

首先连接建立更快。HTTP2.0基于TCP连接需要三次握手的过程。而HTTP3.0继承TLS1.3支持0RTT和1RTT快速握手。另外http3.0的头部压缩更高效。另外http2.0多个请求复用一个TCP连接，单个数据包丢失导致所有请求被阻塞，而http3.0支持多个独立数据流，解决堵塞问题。

# 什么是 WebSocket?⼀般⽤来做什么？

websocket基于tcp的全双工协议，允许client和server简历持久连接，并且可以实时双向数据传输。一般用来做视频弹幕，实时消息推送以及实时游戏对战。

# WebSocket 和 HTTP 有什么区别？

websocket提供全双工通信，允许client和server同时发送和接受数据。而http是单项请求响应协议。websocket协议前缀是ws，而http就是前缀。websocket的头部信息量小开销比http小。

# WebSocket 的⼯作过程是什么样的？

连接初始化，服务器响应，数据传输，保持链接，连接关闭。初始化阶段client向server发送一个特殊的http请求。server响应阶段他会发送http switching protocols响应。保持连接时可以通过发送心跳包维持回话。关闭连接任一方可以发送一个关闭帧。

# SSE 与 WebSocket 该如何选择？

sse基于标准的http工作，而websocket是独立的协议。sse仅支持单向通信，websocket支持全双工通信。websocket适合需要双向通信应用如在线游戏，而sse适合单向数据流，如推送通知、实时新闻报道。

# PING 命令的作⽤是什么？

用于测试从一个网络设备到另一个设备的连通性。通过icmp回声请求报文实现。他会显式目标主机的域名和IP地址以及rtt。

# PING 命令的⼯作原理是什么

基于icmp协议使用echo Request和echo reply报文实现。

# DNS 是什么？解决了什么问题？

DNS是域名解析系统，解决了域名和IP地址的映射问题。

# DNS 能解析端⼝吗？

不解析，端口号属于传输层的范畴，DNS操作于应用层。

# DNS 服务器有哪些？

DNS有4类服务器，根DNS服务器，顶级域名服务器，权威服务器，本地服务器。根管理顶级域名服务器地址信息，处理对顶级域名服务器的查询请求。顶级域名服务器管理com org net的域名信息。权威服务器管理他负责的域名的DNS记录。本地服务器由ISP维护，作为client和更高级别DNS服务器之间的中介。

# DNS 劫持了解吗？如何应对

DNS劫持通过修改DNS服务器解析结果，使用户访问的域名指向错误的IP地址，从而引导到恶意网站。应对方式有网络层面和应用层面的方法。网络层面使用多个域名，主域名受到攻击使用备用域名，另外可以修改DNS服务器改为更可靠的公共DNS服务。应用层面使用HTTP DNS替代传统的local DNS，通过HTTP协议直接请求专门DNS解析服务，绕过本地ISP DNS服务。

# IP 协议的作⽤是什么？

IP（Internet Protocol，网际协议） 是 TCP/IP 协议中最重要的协议之一，属于网络层的协议，主要作用是定义数据包的格式、对数据包进行路由和寻址，以便它们可以跨网络传播并到达正确的目的地。

# 什么是 IP 地址？IP 寻址如何⼯作？

IP地址是互联网协议地址，有IPv4和ipv6，在网络通信中每个数据包有源IP地址和目的IP地址，他们帮助网络设备正确路由数据包

# IPv4 和 IPv6 有什么区别？

ipv4使用32位地址，已不足以满足全球需求。ipv6使用128位地址，理论上提供了几乎无限的IP地址。另外ipv6不需要NAT来允许多个设备共享一个公共IP地址。

# 操作系统

# 操作系统的调度算法了解吗？

先来先服务算法，最短作业优先算法，高响应比优先算法，高响应比就是说权衡等待时间和要求服务时间，时间片轮转算法。

# 算法

# 写出三种单例模式的实现？你推荐哪⼀种？

枚举类实现。effective Java推荐的方式，无需加锁，线程安全，可以避免 反射破坏枚举单例。静态内部类实现，推荐。单例类的构造方法私有化，并且还有额外的静态内部类有静态最终单例类实例，当getInstance方法调用时，静态内部类才会被加载，单例类才会被初始化。双重校验锁模式。在懒汉式基础上做改进，它的Synchronized没有放在getInstance方法上，而是在if instance==null里面，再锁定当前类，然后再校验instance为null，然后创建对象。

# 加权轮询算法实现

加权轮询算法用于负载均衡。权重越高的服务器越有可能被选中。

# 实现⼀个死锁

Thread t1先获取Synchronized resource1，等待100毫秒，然后获取Synchronized resource2，t2反过来这就产生了死锁。

# ⽣产者和消费者实现

生产者方法while等待队列的size不为满，wait方法，然后生产一个值，执行notify方法。消费者方法while等待队列的size不为空，wait方法，然后消费一个值，执行notify方法。

# 数据结构

# 数组 vs 链表

数组的插入和删除的时间复杂度是O（n），而链表插入删除时间复杂度是O（1）。

# 栈的应⽤场景

表达式求值，以及函数调用的管理，如虚拟机栈。

# 队列的分类、应⽤场景

普通队列，用于广度优先算法。双端队列，用于滑动窗口问题。循环队列用于环形缓冲区。优先队列，用于任务调度如CPU任务调度。

# 红⿊树的特点、红⿊树 vs ⼆叉查找树

红黑树能在log n时间内实现插入删除查找操作，每个节点是红色或黑色，根节点是黑色，红色节点的子节点必须是黑色的，每个节点到所有后代叶子节点的简单路径上包含相同数目的黑色节点，叶子节点都是黑色的空节点。红黑树是一种平衡的二叉查找树，结合了平衡二叉树和二叉查找树的特点。

# 哈希表应⽤场景

哈希表可用于快速查找与缓存，如Memcached以及数据库索引。哈希表用于键值对存储如HashMap。哈希表用于内存地址映射，页表使用哈希表映射虚拟地址到物理内存地址。

# 布隆过滤器应⽤场景

布隆过滤器时一种空间效率极高的概率型数据结构，用于判断一个element是否属于一个集合，但可能错误认为一个不存在的element存在于集合中，假阳性，误判率取决于哈希函数的选择以及位数组的大小，但不会将存在的元素误判为不存在。应用场景有垃圾邮件过滤，以及缓存系统中的热点数据识别，避免频繁访问MySQL。

。