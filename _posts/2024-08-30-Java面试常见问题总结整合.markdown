# 数据库

# SQL分组

group by将查询结果按照一个或多个值分组，然后对每个分组进行聚合计算，如SUM

，AVG，COUNT，也可以使用HAVING过滤分组结果。

# SQL连接

在两个表之间建立关系。inner join，返回两个表符合连接on条件的记录。不加修饰符的join默认就是inner join。

# 索引底层的数据结构了解么？Hash 索引和 B+树索引优劣分析（字节考过）

Hash 索引基于哈希表（Hash Table）。哈希表使用哈希函数将键映射到表中的一个位置，以支持快速的数据查找操作。哈希表中的每个槽（bucket）可能包含一个或多个记录，通过哈希函数计算出来的值决定了记录的位置。**B+ 树是一种自平衡的树数据结构，每个节点包含多个子节点和关键字。所有数据都存储在叶节点中，内部节点仅作为路由信息。**

B+ 树的特点是所有叶子节点都在同一层，并且有序。Hash索引缺点是不支持范围查询以及哈希冲突问题。B+树缺点是插入删除需要平衡操作，另外他有额外的空间占用。

# binlog格式有几种？（或者问MySQL主从复制有哪些，饿了么考过）

statement格式，每条修改数据的SQL记录在binlog中。row格式，每个数据行的变更事件记录在binlog中。以及mixed格式，两种方式混合。

# 有哪些常⻅的 SQL 优化⼿段？（帆软，滴滴考过）

避免使用select*，深度分页优化，避免超过3个表做join，不要用外键和级联，用union all代替union，show profiles和show profile命令查看执行时间。优化慢sql，通过set global show slow query log开启慢查询日志，然后用explain 分析对应的select语句，比较重要的字段有select type，指的是查询的类型，比如simple没有联合查询和子查询，table字段表示涉及到的表，**type**是**慢查询重要参考指标**，all，index，range，ref，eq_ref，const，System逐渐从差到好。最后是正确使用索引，被频繁更新的字段应慎重建立索引，尽量联合索引而不是单列索引。

# 索引失效的原因有哪些？（美团，携程，腾讯云智）
创建了联合索引，但查询条件不遵守最左匹配原则。
使用模糊查询，like %。
查询条件中使用or，而且or的条件中有一个列索引没有命中。
查询子句中操作符左右两边数据类型不一致，发生隐式转换。

# mysql底层的存储的数据结构是什么？（美团）
innodb引擎。b+树，每个表的主键索引和二级索引都使用b+树来存储数据。b+树是平衡树，能够高效支持范围查询和顺序访问。

聚集索引。在innodb中，数据实际是存储在主键索引的叶子节点中的。主键索引叶子节点不仅包含索引键值，还包含整行的数据。

myisam引擎。myisam的索引和数据是分开存储的。数据存储在单独的文件中，而索引存储在另一个文件中，索引叶子节点只包含指向数据行的指针。

无论是什么数据引擎，数据都是以页为单位存储的。页之间通过双向链表连接。

# MySQL主键索引和普通索引谁的性能好一些？如果在10万数据下，谁的性能更好？（腾讯）

主键索引是唯一且非空索引，通常是自增的整数类型，由于唯一非空所以查询速度非常快。

普通索引，是非唯一索引，可以包含重复值，需要额外步骤来找到实际数据，因此在10万数据量下，性能稍差于主键索引。

实际应用还要考虑数据分布和查询需求，比如数据分布均匀且查询需求明确，主键索引更好。如果查询涉及多个字段，需要创建复合索引，普通索引更有优势。

# 以abc为例，在什么情况下，单查询b也能够命中联合索引？（腾讯）

联合查询遵循最左匹配原则，如果查询条件只涉及b，那么MySQL会尝试使用索引前缀部分。如果查询条件是where b=某个值，MySQL会先找a的值，然后在a的值相同下找b的值，如果a的值与b的值唯一确定，那么查询就可以命中索引。

# 同一条SQL，不同规模的数据会走同一条索引吗？
索引选择的基本原则。索引是基于查询的条件和数据的分布来决定的。数据库优化器会根据统计信息和查询计划来选择最优的索引。

数据规模的影响。对于不同规模的数据，数据库优化器会选择不同的索引。比如，对于小规模数据，全表扫描可能比使用索引更快，因为索引查找本身也有开销。而对于大规模数据，使用索引可以显著减少查询时间，因为全表扫描代价 非常高。

在实际应用中，我们可以通过explain语句查看sql查询的执行计划，了解数据库优化器选择了哪个索引。

# 数据库b+树索引能存多少数据？（美团）
b+树是平衡树，每个节点可以存储多个键值对。非叶子节点存储键值和指向子节点的指针，而叶子结点存储实际数据。

影响存储容量的因素。
节点大小。b+树每个节点有固定的大小。
键值大小。键值越大，单个节点能存储的键值对就越少。
树的高度，b+树高度决定了从根节点到叶子节点的路径长度。高度越低，查询效率越高。

在实际应用中，b+树的存储容量取决于上面提到的因素。比如，每个节点大小为4K字节，键值大小为8字节，指针大小为4字节，那么每个节点大约可以存储400个键值对。假设树的高度为3，那么整个b+树可以存储400的3次方，6400万个键值对。

# B+树相对于B树的优点是什么？（虾皮，快手）
数据存储方式。b+树所有数据都存储在叶子节点上，非叶子节点只存储索引信息，这种方式使得非叶子节点可以存储更多索引，减少树的高度。

叶子节点链表，b+树叶子结点形成一个链表，便于顺序访问。

# 结合B+树结构讲讲为什么一定要最左匹配才行？（快手）
B+树基本结构。B+树是一种多路搜索树，每个节点可以有多个子节点，在B+树中，数据都存储在叶子节点上，而非叶子节点只存储索引信息。

最左匹配。索引的构建是基于从左到右的列顺序，查询时，如果跳过了某个列，后续列值的位置就无法准确定位。

# MySQL 的隔离级别是基于锁实现的吗？

是的，隔离级别是基于锁和mvcc实现的，读未提交没使用锁，读已提交使用共享锁读取已提交数据，可重复读使用mvcc实现，可串行化对读使用共享锁，对写使用排他锁。

# InnoDB 对 MVCC 的具体实现（快手）

通过隐藏列，读视图，undolog，实现mvcc。隐藏列包含db_trx_id表示最近修改该行的事务id等。读视图使得事务只能看到最近修改事务id小于他的行。undolog保存事务修改之前数据的版本。

# mvcc的实现原理是什么？读已提交和可重复读隔离级别下mvcc实现的区别是什么？
版本控制。mvcc的思想是为每个数据行维护多个版本，每个版本对应一个事务id，这样不同的事务可以同时看到数据的不同版本。
事务id。每个事务开始前分配一个唯一事务id，读取时，事务只能看到他之前的数据版本。
版本链。每个数据行都有版本链，链中每个节点代表一个数据版本，当一个事务修改数据时，会创建一个新的版本节点，并插入到版本链中。
快照读。mvcc在事务读取时，会创建一个数据的快照，在整个事务期间使用这个快照。

区别。
在读已提交隔离级别下，mvcc的实现相对简单，事务在读数据时，只会读已提交的版本，如果一个事务正在修改数据，其他事务看到修改前的版本。
可重复读隔离级别下，mvcc实现相对复杂，事务读数据时，会锁定读取的版本，确保整个事务期间，读取的事务版本不会发生变化。

# char 和 varchar 的区别是什么？

char固定长度，如char10不管存的是什么都是10个字符空间，varchar可变长度，如varchar10，如果存储abc，只用3个字符空间。

# decimal 和 float/double 的区别是什么？存储钱应该⽤哪⼀种？

float 和 double 是浮点数，适合需要处理非常大或非常小的数值的场景，但它们可能会有舍入误差。decimal 是定点数，可以提供精确的十进制表示，适合需要精确计算的场景。存储钱应该使用decimal。

# 为什么不推荐使⽤ text 和 blob？

TEXT 和 BLOB 类型字段的大小可能非常大，导致索引性能下降。MySQL允许对这些字段建立全文索引，但由于字段内容的体积，建立和维护这些索引的开销较大。

# 为什么索引能提⾼查询速度?

索引可以**减少磁盘I/O操作**，因为它只要读取索引部分而不是整个数据表，**全表扫描非常耗时**。另外，索引可以加速排序操作order by子句，因为索引本身是排序好的数据结构。

# 聚集索引和⾮聚集索引的区别？⾮聚集索引⼀定回表查询吗?

聚集索引即索引结构和数据一起存放的索引。主键索引属于聚集索引。非聚集索引即索引结构和数据分开存放的索引。不一定，是否需要回表查询取决于索引是否覆盖了查询中所需的所有列。

# 索引这么多优点，为什么不对表中的每⼀个列创建⼀个索引呢？(使⽤索引⼀定能提⾼查询性能吗?)

索引并不都是好的，创建索引和维护索引也需要耗费资源和时间。

# B+树做索引⽐红⿊树好在哪⾥？

所有节点都在底下一层，支持范围查询，节点容量大。

# 最左前缀匹配原则了解么？

在 MySQL 建立联合索引时会遵守最左前缀匹配原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。

# 什么是覆盖索引

覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了，而无需回表查询。

# 如何查看某条 SQL 语句是否⽤到了索引？

EXPLAIN关键字分析SQL语句，返回的key列展示了查询使用的索引。

# 哪些操作会加表级锁？哪些操作会加⾏级锁？请简单举例说⼀下

alter table会加表级锁，update以及for update会加行级锁。

# MySQL 如何使⽤乐观锁和悲观锁？

乐观锁，可以用version版本字段，在update时检查版本号是否匹配，匹配则增加版本号。悲观锁，使用select for update加行级锁。

# 慢查询⽇志有什么⽤？

慢查询日志记录了执行时间超过 long_query_time（默认是 10秒）的所有查询，在我们解决 SQL 慢查询（SQL 执行时间过长）问题的时候经常会用到。

# 如何查询当前慢查询的个数？

有个变量专门记录，show global status like ‘%Slow_queries%’，即slow queries这个变量。

# 讲一讲慢查询怎么处理？
  识别慢查询
通过慢查询日志查看具体的SQL语句，了解哪些查询耗时长。
  分析慢查询原因
常见原因，索引缺失，查询条件不合理，数据量过大，可以用explain命令分析SQL执行计划，看看是否走了索引以及是否存在全盘扫描。
  优化慢查询
添加合适索引，或者优化查询条件。

# binlog 主要记录了什么？

主要记录了 MySQL 数据库中数据的所有变化(数据库执行的所有 DDL 和 DML 语句)。

# binlog刷盘时机怎么选择？

事务在执行过程中，先把日志写入binlog cache中，只有事务提交时，才把binlog cache持久化到磁盘上的binlog文件中。默认每次提交事务的时候将binlog写入磁盘。

# 什么情况会重新生成binlog？

MySQL重启或停止，或者使用flush logs命令，或者binlog文件超过max_log_size后。

# redo log 如何保证事务的持久性？

InnoDB以页为单位管理存储空间，往MySQL插入的数据存在于页中的。为减少磁盘开销，有一个buffer pool存在于内存中。redo log 主要做的事情就是记录页的修改，比如某个页面某个偏移量处修改了几个字节的值以及具体被修改的内容是什么。在事务提交时，我们会将 redo log 按照刷盘策略刷到磁盘上去，这样即使 MySQL 宕机了，重启之后也能恢复未能写入磁盘的数据，从而保证事务的持久性。

# redolog什么情况会出现丢失数据？

如redolog写入log buffer但未写入page cache，page cache是文件系统缓存，此时db崩溃，就会出现数据丢失。

# ⻚修改之后为什么不直接刷盘呢？

性能非常差！InnoDB 页的大小一般为 16KB，而页又是磁盘和内存交互的基本单位。这就导致即使我们只修改了页中的几个字节数据，一次刷盘操作也需要将 16KB 大小的页整个都刷新到磁盘中。而且，这些修改的页可能并不相邻，也就是说这还是随机 IO。

# binlog 和 redolog 有什么区别？

binlog用于数据库还原，属于数据级别的数据恢复，主从复制是binlog的应用场景。redolog属于事务级别的数据恢复。**redolog**是**InnoDB引擎特有**的，binlog是所有存储引擎共有的，binlog是MySQL的server层实现的。redolog是物理日志，记录的是某个页的修改。binlog属于逻辑日志，记录的是数据库执行的所有DDL和DML语句。

# undo log 如何保证事务的原⼦性？

每一个事务对数据的修改都会被记录到 undo log ，事务中的操作如插入更新删除，对应的逆操作都记录在undo log中。undolog的信息也会被记录在redolog中，保证持久性。对于undolog的清理，如果是insert操作的undolog，在事务提交后立即删除，如果是update或delete操作的undolog，不会被立即删除，这些log被添加到history list中，等待purge线程处理。undolog的存储结构是段式，每个undo操作占用一个undolog segment。

# 除了保障事务原子性，undolog还有什么用？

mvcc的实现依赖于读视图和undolog，如果数据行不可见，则通过这一行的指针找到undolog的历史版本。

# 能⽤ MySQL 直接存储⽂件（⽐如图⽚）吗？

可以但是存在性能问题，使用blob存储二进制数据。

# MySQL 如何存储 IP 地址？

用字符串varchar占空间，MySQL用Inet aton把IP地址转为无符号整数，inet ntoa把整数转化为IP地址。

# 如何分析 SQL 的性能？

EXPLAIN 是分析查询语句性能的最重要工具之一，可以判断查询是否使用了合适的索引，是否存在不必要的全表扫描，以及多表查询的连接顺序是否合理。通过配置文件或动态设置可以启用慢查询日志，SET GLOBAL slow_query_log = 'ON'。

# 简单说⼀下⼤表优化的思路

合理设计索引，针对经常使用在where，join，order by和group by的列建立索引。采用分区表，如将大表按照日期，ID范围分区 ，减少扫描范围。以及采用分库分表方法，将数据按业务规则分散到多个表或库中，减少单个表的压力。

# 为什么单表数据量过大会查找效率变慢？为什么磁盘查找会变高？

  1. 单表数据量大的影响

-**数据量增加**：随着单表数据量的增加，数据库需要处理的数据量也会随之增加。
-**索引效率下降**：索引是为了加速查询而存在的，但当数据量过大时，索引的维护成本会变高，查询效率会下降。

  2. 查找效率变慢的原因

-**索引失效**：当数据量过大时，索引可能无法完全加载到内存中，导致索引失效，查询需要进行全表扫描。
-**磁盘I/O增加**：全表扫描意味着需要从磁盘读取大量数据，磁盘I/O操作的次数和时间都会增加，导致查询效率变慢。

  3. 磁盘查找变高的原因

-**磁盘碎片**：随着数据量的增加，磁盘碎片也会增加，进一步增加了磁盘查找的时间。

# 读写分离如何实现？

使用MySQL内置的主从复制机制，将主库的变更复制到从库。首先在主库上通过log-bin配置文件启用二进制日志，然后再从库上通过relay-log配置启用复制，最后在从库上执行Change master to 命令指向从库。

# 为什么要分库分表？有哪些常⻅的分库分表⼯具？

首先要提升性能，减少单表数据量。然后提高可拓展性，实现更高的并发，最后是提高可用性，即使某个库出现问题，也只会影响部分业务。常用的分库分表工具有MyCat，基于阿里的Cobar架构。以及shardingsphere，Apache的开源分布式db中间件。

# 深度分⻚如何优化？

深度分页指的是当查询结果集非常庞大时，用户请求的是结果集的某个较深的页面（例如，第1000页）。优化方案，如范围查询，子查询，延迟关联和覆盖索引。

当保证id连续时，根据id范围分页。

子查询，先查出limit第一个参数对应的主键值，再根据主键值过滤并limit，会产生一张新表，只适用于id正序。

延迟关联，也是把条件转移到主键索引树，和子查询一样，不过用join实现。

覆盖索引，把要查询的列建立覆盖索引，避免InnoDB回表操作。

# 数据冷热分离如何做？

冷热数据的识别，如几年前的日志、过期订单或者访问量低的数据等，当做冷数据。数据库设计，热表存储近期的数据，冷表存储历史数据。**冷数据的迁移**，可以用xxl-job分布式调度平台定时扫描数据库，找出冷数据，批量复制到冷库，然后从热库中删除。或者从binlog中提取满足冷数据条件的数据，然后复制到冷库，从热库删除。

# redis

# Redis 为什么这么快？（滴滴考过）

首先Redis 的大部分操作都在内存中完成，并且采用了高效的数据结构，因此 Redis 瓶颈可能是机器的内存或者网络带宽，而并非 CPU。其次Redis 采用**单线程模型**可以避免了多线程之间的竞争，省去了多线程切换带来的时间和性能上的开销。最后，Redis 采用了 I/O 多路复用机制处理大量的客户端 Socket 请求，IO 多路复用机制是指一个线程处理多个 IO 流，就是我们经常听到的 select/epoll 机制。简单来说，在 Redis 只运行单线程的情况下，该机制允许内核中，同时存在多个监听 Socket 和已连接 Socket。

# 缓存穿透和缓存击穿有什么区别？缓存雪崩和缓存击穿有什么区别？（滴滴考过）

缓存穿透是，当用户访问的数据，既不在缓存中，也不在数据库中，导致请求在访问缓存时，发现缓存缺失，再去访问数据库时，数据库中也没有要访问发现的数据。缓存击穿是，如果缓存中的某个热点数据过期了，此时大量的请求访问了该热点数据，就无法从缓存中读取，直接访问数据库。缓存雪崩是，大量的用户请求，都无法在 Redis 中处理，于是全部请求都直接访问数据库，从而导致数据库的压力骤增，严重的会造成数据库宕机，从而形成一系列连锁反应，造成整个系统崩溃。

# redis的主从复制有哪两个？（饿了么考过）

redis的主从复制有同步复制和异步复制两种。

# zset为什么采用跳表，而不使用哈希表或平衡树实现呢？（网易）
性能方面。跳表在增删查都是Log n时间，与平衡树相当，但实现更简单。哈希表虽然查找时O 1，但是处理范围查询效率较低。

实现复杂度。跳表实现比平衡树简单，不需要复杂的平衡调整，代码量少。哈希表需要处理哈希冲突，而且扩容时要重新哈希，增加实现的复杂度。

内存占用。跳表的每个节点包含的指针数目平均为1/(1-p)，而平衡树每个节点包含2个指针，内存占用更小。哈希表在处理大量数据时，可能因为哈希冲突导致内存占用增加。

# 在数据量比较少时，跳表相对于其他数据结构缺点是什么？（网易）
空间复杂度。跳表在数据量少时，空间复杂度显得比较高。因为跳表需要维护多层索引，即使数据量不多，也需要为每一层分配空间。

插入删除复杂度。虽然跳表插入删除平均复杂度是Log n，但是在数据量少时，可能并不比其他数据结构如链表的O 1有优势。

# 设计一个抖音视频热度排行榜，假设存量两百亿，日增量一千万？

使用zset，将**视频id**作为元素，视频的热度作为分数，可以实时更新排行榜。但是，如果日增量非常大如1000万，直接添加到zset可能导致性能问题，因为zset的插入复杂度是O log n。

  **流量压力**的考虑
为了应对这种情况，可以考虑以下几种优化方案：
  1.**分片**：将**ZSET**分片到多个Redis实例上，每个实例负责一部分数据。这样可以分散流量压力。
  2.**批量处理**：将日增量数据先缓存起来，然后批量插入到**ZSET**中，减少单次插入的次数。
  3.**增量更新**：只更新发生变化的视频热度，而不是全量更新。这样可以减少不必要的操作。


# Redis几种数据类型怎么实现的？

reids有五种数据类型，String List Hash Set Zset。String的实现是基于SDS的，拼接字符串不会造成缓冲区溢出。List基于**quicklist**实现，quicklist是双层结构，内部有多个node，每个node是一个ziplist或者linkedlist。hash基于listpack或哈希表实现。set基于整数集合或哈希表实现。zset基于listpack或跳表实现。

# zset的时间复杂度是什么？

zset如果元素比较多，那么用跳表实现，跳表的增删查的时间复杂度都是O log n，但是最坏情况下是o n，这时没有建立有效的索引。

# 本地缓存和分布式缓存有什么区别？如何选择？

本地缓存存储在本地应用程序或服务器内存中。而redis存储在分布式缓存系统多个 节点上。当数据量小，对实时性要求高时选用本地缓存，数据量较大，需要高并发选择redis缓存。

# 本地缓存有哪些缺点？

本地缓存和应用耦合，对分布式架构不友好。

# 什么是多级缓存?为什么要用？

多级缓存是本地缓存+分布式缓存的多级缓存方案。使用的原因是本地缓存的访问速度远大于分布式缓存。

# 多级缓存一致性怎么保证？

缓存更新策略。主动更新，在数据发生变化时，主动更新缓存。比如在数据库更新后，立即更新对应的缓存数据。

被动更新，设置缓存的过期时间，一定时间后缓存自动失效，从数据库中重新加载。

分布式锁。在更新缓存时，使用分布式锁确保同一时间只有一个线程可以更新缓存，避免并发更新导致数据不一致。

消息队列。在数据更新后，发一个消息到队列，其他节点监听到消息后同步更新自己的缓存。

# 常见的缓存更新策略有哪些？

旁路缓存模式。写先更新db然后直接**删除cache**。读从cache读取数据读到直接返回,没有则找db，再把db 数据放到cache中。

读写穿透模式。写先查cache，cache不存在直接更新db，若cache存在则先更新cache然后cache自己更新db。读，从cache读取数据，读到就返回，读不到先从db读，写入cache后返回。

异步缓存写入模式，和读写穿透模式差不多，不过在写的时候如果cache存在则先更新cache，然后异步更新db 。

写db后删除cache是因为cache存放的数据要服务端进行大量计算才能得出，如果频繁修改db，就会导致经常更新cache，而cache可能都没有被访问过。

旁路缓存模式的缺陷有首次请求数据一定不在cache的问题，通过热点数据提前放入cache解决。 另外是写频繁导致cache数据频繁删除，影响缓存命中率。如果是强一致性场景，则更新db时同步更新cache，不过要加一个分布式锁保证更新cache时候不存在线程安全问题。如果cache删除失败，隔一段时间重试，设置重试次数，达重试次数还没成功，则把这个失败的key放到队列中，等这个cache能用后，在把key删除。

# 什么是 Redis Module？有什么⽤？项⽬使⽤过吗？

Redis Module 是 Redis 4.0 引入的一项功能，允许开发者通过插件的方式扩展 Redis 的核心功能。用处，module可以拓展数据结构和命令，如布隆过滤器，图等数据结构。常见的Redis module有redisearch，redisjson。

# 如何基于 Redis 实现分布式锁？

redis的setnx可以实现分布式锁的互斥性，如果key存在，set不会成功，返回0。释放锁使用del直接删除key。可以通过设置过期时间防止锁死，如set suo 1 ex 3 nx，3秒删除。结合看门狗机制，如renewExpirationAsync方法实现续期。nx是not exist的缩写，ex是expire的缩写。

# Redis 可以做搜索引擎么？

可以，采用rediseasrch，可以在redis上实现全文搜索，模糊匹配，排序，过滤等功能。

# Redis 为什么⽤跳表，⽽不⽤平衡树、红⿊树或者B+树？

首先从内存占用上来比较，跳表比平衡树更灵活一些。平衡树每个节点包含 2 个指针（分别指向左右子树），而跳表每个节点包含的指针数目平均为 1/(1-p)，因为跳表每层提升的概率是p，累加就是一个无穷级数。

其次，在做范围查找的时候，跳表比平衡树操作要简单。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。而在跳表上进行范围查找就非常简单，只需要在找到小值之后，对第 1 层链表进行若干步的遍历就可以实现。

最后，从算法实现难度上来比较，跳表比平衡树要简单得多。平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而跳表的插入和删除只需要修改相邻节点的指针，操作简单。

# Redis为什么使⽤ ListPack 替代 ZipList?

ziplist是一种紧凑的编码格式，用于redis的zset和hash的底层实现。在ziplist中prevlen是可变长编码，如新元素长度是超过253字节的，后续元素prevlen要从1字节拓展到5字节，这又会导致元素自身的长度增加4字节，如果他也超过了253字节，再后续的元素也要1变5.。在listpack中只记录当前节点的长度。因此解决了连锁更新的问题。

# Zset 的应⽤场景是什么？项⽬哪⾥⽤到了？

Zset 类型用于排序场景，比如排行榜、电话和姓名排序等，也可以用于实现延迟队列，延迟是指把要做的事推迟后再做，zset有score属性存储延期时间。

# **Redis 批量操作的⽅式有哪些**？

首先是，管道Pipeline，它允许客户端一次性发送多个命令道redis服务器，只通过一次网络请求实现，然后一次性接受所有命令的响应。其次是multi命令，将一组命令打包成一个事务，顺序执行。然后是lua脚本，使用eval命令将lua脚本发送到redis服务器。最后是mset命令，针对多个键的批量操作命令。

# **为什么会有 Redis 内存碎⽚?如何清理 Redis 内存碎⽚**？

内存碎片可以理解为那些不可用的空闲内存。产生的原因是redis的zmalloc方法向操作系统申请的内存空间大于数据存储需要的空间，另外当redis某个数据删除时，这个空间也不会释放给操作系统。通过配置config set activedefrag yes清理内存碎片。

# **缓存预热如何实现**？

有两种实现方式。

第一种，使用定时任务，比如 xxl-job，来定时触发缓存预热的逻辑，将数据库中的热点数据查询出来并存入缓存中。

第二种，使用消息队列，比如 Kafka，来异步地进行缓存预热，将数据库中的热点数据的主键或者 ID 发送到消息队列中，然后由缓存服务消费消息队列中的数据，根据主键或者 ID 查询数据库并更新缓存。

# 什么是 Sentinel？ 有什么⽤？

sentinel监控 Redis 节点的运行状态并自动实现故障转移。一个简易的sentinel集群包括，3个sentinel节点，2个slave节点，1个master节点，quorum表示判定master失效最少需要的仲裁节点数。

# Sentinel 如何检测节点是否下线？主观下线与客观下线的区别?

主观下线，节点认为某个redis节点已经下线，但不确定，需要其他节点的投票。客观下线，法定数量，通常为过半的节点认为某个redis节点已经下线，那么他就是真下线了。如果客观下线的是master，那么sentinel中会有一个leader节点负责故障转移。

# Sentinel 是如何实现故障转移的？

选出新主节点，将从节点指向新主节点，通知客户端主节点已更换，将旧主节点变为从节点。这个过程由leader节点负责，leader节点通过如raft算法实现选举。故障转移就是每个节点指针的变化。

# Sentinel 如何选择出新的 master（选举机制）?

slave必须是在线才能参加新的master选举。选举有3个维度。第一个slave优先级，配置replica-priority，手动设置。第二个是复制进度，sentinel总是希望选出与旧master数据差异最小的slave升职为新的master。第三个是运行id，万一有多个slave的优先级和复制进度一样的话，选择runid小的成为新的master。

# Sentinel 可以防⽌脑裂吗？

可以，脑裂就是网络问题，导致主从节点失去联系，从节点选出自己的主节点，等网络恢复，后选出的主节点会被降级为从节点，再进行同步复制的时候，就会丢失数据。解决方法时当发现从节点下线时，禁止主节点进行写数据，可以配置min-slave-to-write x以及min-slave-max-lag x。

# 为什么需要 Redis Cluster？解决了什么问题？有什么优势？

保障redis服务高可用。解决单节点在拓展性和可用性的限制。优势有，通过主从复制提供故障恢复能力，以及可以通过添加节点增加存储计算能力，以及数据自动分布在集群不同节点上。

# Redis Cluster 是如何分⽚的？

使用槽的概念来管理分片，整个集群分为16384个槽，每个槽包含一定范围的健，redis用crc16哈希算法将键映射到某个槽，redis用Gossip协议传播集群状态信息，如节点状态和槽分配信息。

# 为什么 Redis Cluster 的哈希槽是 16384 个?

哈希槽太大会导致心跳包太大，消耗太多带宽。

哈希槽总数越少，对存储哈希槽信息的 bitmap 压缩效果越好。

Redis Cluster 的主节点通常不会扩展太多，16384 个哈希槽已经足够用了。

# 如何确定给定 key 的应该分布到哪个哈希槽中？

首先计算key的crc16哈希值，假如结果为12345，然后计算槽编号，12345%16384，结果为4597，查找redis集群的槽到节点的映射表，找到负责4597的节点。

# Redis Cluster ⽀持重新分配哈希槽吗？

支持重新分配哈希槽，使用cluster addslots命令添加。

# Redis Cluster 扩容缩容期间可以提供服务吗？

扩缩容期间可以提供服务。提供了重定向机制。ASK 重定向:可以看做是临时重定向，后续查询仍然发送到旧节点。MOVED 重定向:可以看做是永久重定向，后续查询发送到新节点。

# Redis Cluster 中的节点是怎么进⾏通信的？

基于gossip协议通信，节点之间会发送多种gossip信息。meet信息，将一个节点添加进cluster。ping pong信息，交换节点的状态信息，疑似下线状态pfail和下线状态fail。fail信息，a节点发现b节点pfail，并在下线报告有限期内cluster内半数以上节点将b标记未pfail则a广播fail消息通知大家b节点为fail。

# Java基础

# 谈谈对 Java 注解的理解，解决了什么问题？

Java 注解（Annotations）是一种元数据（metadata），用于为程序元素（如类、方法、变量、参数等）提供附加信息。注解不会直接影响程序的逻辑，但可以通过编译时或者运行时的工具进行处理，以实现如自动化配置功能。解决的问题，如减少样板代码，提高代码可读性并与框架结合。

# 注解的实现原理？

注解本质是一个**继承了Annotation**的特殊接口，其具体实现类是Java运行时生成的动态代理类。我们通过反射获取注解时，返回的是Java运行时生成的动态代理对象。通过代理对象调用自定义注解的方法，会最终调用AnnotationInvocationHandler的invoke方法。该方法会从memberValues这个Map中索引出对应的值。而memberValues的来源是Java常量池。

# Java 反射？反射有什么缺点？为什么框架需要反射？

反射是一种机制，允许我们在运行时检查和操作类，方法，字段等。简单来说，反射让我们在编译时不确定的情况下，动态获取类的信息并调用方法。

反射的优点是可以在运行时动态创建对象调用方法，在spring框架中非常有用。

反射的缺点是性能问题，反射比直接调用方法要差，因为反射涉及到大量的内部检查和动态解析。安全性。反射可以访问和修改类的私有成员，可能会破坏封装性。

为什么框架需要反射。很多框架，使用反射实现依赖注入。通过反射，框架可以在运行时根据配置文件或注解创建和管理对象。

反射在实现aop时也非常重要，他允许我们在不修改源代码情况下，动态的插入横切逻辑。

# 动态代理的实现方式有哪些？怎么选择对比？
jdk动态代理和cglib动态代理两种方式。
jdk动态代理。通过实现invocation handler接口，并用newProxyInstance方法来创建代理对象。
cglib动态代理。通过生成目标类的子类实现的，使用enhancer创建代理对象。
选择和对比。
目标类是否实现了接口，如果实现了接口，我会优先考虑jdk动态代理，因为他更轻量级。
性能。cglib因为直接操作字节码所以通常比jdk动态代理稍微快一些。
依赖。如果项目中已经引入cglib，或者有其他组件依赖cglib，那我会优先考虑cglib动态代理。

# Java 泛型了解么？什么是类型擦除？介绍⼀下常⽤的通配符？

泛型是Java5引入的特性，允许类，接口和方法能操作对象的类型，实现代码的参数化类型。泛型在编译时检查类型，避免运行时ClassCastException。类型擦除，指泛型类型在编译后被擦除，在运行时不存在泛型信息。问号 是无界通配符，可以接受任意类型。问号 extends T，上界通配符，传入的类型必须是T的子类型，上界通配符只能从父类读取数据，不能添加数据。

# 内部类了解吗？匿名内部类了解吗？

定义在一个类内部的类，匿名内部类是没有名字的内部类，在使用时定义和实例化。应用场景如按钮点击事件处理器。

# BIO,NIO,AIO 有什么区别?

bio是最传统的io模型，在读写操作时会**阻塞**当前线程，直到操作完成。这意味着如果一个线程在等待io完成时，他不能做其他事情。

nio是java1.4中引入的，支持非阻塞io操作。这意味着线程在发起io请求后可以继续执行其他任务，而不必等待io操作完成。nio引入了**channel**和**buffer**的概念，通过**selector**实现单线程管理多个channel，提高并发处理能力。适合高并发的网络请求场景。

aio是java7引入的，提供了异步io操作。在aio中， io操作会立即返回，操作完成后通过回调或Future对象通知应用程序。这种方式适合处理长时间io操作，如文件读写或网络传输。

# final，finalize，finally之间的区别
final用于声明变量，不可重写方法，不可继承的类。
finalize是**Object**类的一个方法，用于在对象被垃圾回收之前执行清理工作。
finally用于定义无论是否发生异常都会执行的代码块。

# Java并发进阶

# 悲观锁和乐观锁了解么？如何实现乐观锁？（字节考过）

悲观锁，假定会发生并发冲突，在数据被访问之前加锁，适用于写频繁场景，Java中通过ReetrantLock或synchronized实现。乐观锁假设数据竞争不会发生，不会在开始加锁，而是在提交数据检查冲突，如版本号检查，若冲突则重试，适合读频繁场景。

乐观锁用版本号或者cas实现。

# cas了解吗？原理是什么？（快手）

很多地方用到了cas，比如Concurrenthashmap采用cas和Synchronized保证并发安全。cas的原理是**unsafe**类中的native方法**compareandswapobjecct**实现，它调用本地代码来做，和具体操作系统和cpu密切相关。cas存在aba问题，一个值原来是a，变成了b，又变回了a，cas是检查不出来变化的，但实际上被更新了两次，aba问题通过加上版本号或者时间戳解决。

# 线程池处理任务的流程了解吗？（讯飞考过）

提交一个任务，如果**核心线程没有满**，就创建一个线程，如果满了，就是会加入等待队列，如果**等待队列满了**，就会增加线程，如果**达到最大线程数量**，就会按照一些丢弃的策略进行处理。

# Java 内存区域和 JMM 有何区别？

Java内存区域包含五个部分，虚拟机栈，本地方法栈，程序计数器，方法区，堆。他是执行Java程序的内存布局。Java内存模型定义了多线程如何进行内存访问的规则。有主内存和工作内存的概念。主内存是共享的，工作内存是独享的。

# happens-before 原则说一下

他是一个偏序关系，如A happens before B，那么a的所有写操作在b开始之前对b可见，JMM定义了几条规则，如在一个线程内，顺序的前面的操作先于后面的操作。**对一个锁的解锁先于加锁动作。**对volatile变量的写操作先于读操作。

# 线程池有什么⽤？为什么不推荐使⽤内置线程池？

提高性能，线程创建和销毁开销大，线程复用可以减少开销。提高稳定性，线程池可以限制最大线程数。

为什么不推荐内置的线程池，如FixedThreadPool，他用了无界队列，如果提交过快，任务会无限积压，导致OOM错误。推荐使用ThreadPoolExecutor自定义线程池，指定核心数，最大线程数，饱和策略。

# 内置线程池有哪些？
fixedthreadpool，数量线程固定的线程池。singlethreadexecutor，只有一个线程的线程池。cachedthreadpool，可以根据实际情况调整线程数量的线程池，若所有线程都在工作，又有新任务提交，则会创建新的线程处理任务。scheduledthreadpool，定期执行任务的线程池。

# 实现 Runnable 接⼝和 Callable 接⼝的区别

runnable适用于不需要返回值的简单后台任务，callable适用于需要返回值或抛出异常的复杂任务。

# 如何给线程池命名？为什么建议给线程池命名？

根据线程池用途来命名，比如taskexecutor，iothreadpool，workerpool等。java中可以用threadfactory创建自定义命名的线程,使用哪个threadfactorybuilder创建命名的线程池。

建议命名的原因。调试和监控，在生产环境中，如果线程池出现问题，通过命名可以快速定位哪个线程池出了问题，方便调试和监控。


```java
ThreadFactory namedThreadFactory=new ThreadFactoryBuilder().setNameFormat("my-thread-pool-%d").build();
ExecutorService pool=new ThreadPoolExecutor(corePoolSize,maximumPoolSize,keepAliveTime,TimeUnit.MILLISECONDS,new LinkedBlockingQueue<Runnable>(),namedThreadFactory);
```

# 如何动态修改线程池参数？

ThreadPoolExecutor提供了一些set方法动态调整参数，如setCorePoolSize

# AQS 原理了解么？AQS 组件有哪些？（阿里）

AbstractQueueSynchronizer，是并发基础框架，使用**状态管理和FIFO等待队列**实现线程排队，支持独占和共享两个模式。组件有ReetrantLock等。

# Semaphore 有什么⽤？原理是什么？

semaphore是Java并发包的一个同步类，用于控制并发访问线程数量，原理基于AQS，通过许可计数器管理线程对资源的访问，它维护一个整型变量permits表示许可数量。

# CountDownLatch 有什么⽤？原理是什么？

countdownlatch是Java并发包的一个同步类，用于协调多个线程的执行顺序，它通过维护一个计数器，允许线程等待其他线程完成任务后再执行，其他线程使用countdown方法使其减一，await方法在数字变为0时会被唤醒。

# CyclicBarrier 有什么⽤？原理是什么？

cyclicbarrier适用于多线程任务需要在某个同步点上等待的场景。原理，创建时，内部维护一个计数器parties跟踪已到达屏障点的线程数，线程调用await方法时，计数器会递减，并使当前线程阻塞，等待其他线程到达await，当所有线程都到了，如果定义了barrierAction，会在这时候执行，然后所有线程继续执行。然后屏障被重置。

# 多个任务的编排可以怎么做？项⽬⽤到了 CompletableFuture 吗？

CompetableFuture可以用于任务编排。顺序执行，可以用thenApply，thenAccept，thenRun，将多个任务串联起来，lamda表达式。并行执行，用allOf和anyOf，并行执行多个任务。

# CompletableFuture怎么处理异常？
使用exceptionally方法。如果异步任务抛出异常，exceptionally会捕获并返回一个默认值或执行一个替代计算，而不是直接失败。
使用handle方法，类似于exceptionally，但是他允许你在处理异常同时，也能处理正常的结果。handle方法接受两个参数，一个是正常结果，另一个是异常，可以根据情况返回不同的值。
使用whenComplete方法，类似于handle方法，但他不会改变CompletableFuture的结果，适用于日志记录。
```java
CompletableFuture<String> future=CompletableFuture.supplyAsync(()->{
  if(someCondition){
    throw new RuntimeException("Oopps!");
  }
  return "Success";
});
```
我们可以用exceptionally处理这个异常：
```java
future.exceptionally(ex->{
  System.out.println("Caught exception: "+ex.getMessage());
  return "Fallback value";
});
```


```java
future.handle((result,ex)->{
  if(ex!=null){
    System.out.println("Caught exception: "+ex.getMessage());
    return "Fallback value";
  }
  return result;
});
```

```java  
future.whenComplete((result, ex) -> {
    if (ex != null) {  
      System.out.println("Caught exception: " + ex.getMessage());  
    } 
    else System.out.println("Result: " + result);
});  
```

# JVM（进阶）

# 垃圾回收算法有哪些?（饿了么考过）

标记-清除算法:标记-清除算法分为“标记“和“清除“两个阶段，首先通过可达性分析，标记出所有需要回收的对象，然后统一回收所有被标记的对象。

复制算法:原理是，将内存分成两块，每次申请内存时都使用其中的一块，当内存不够时，将这一块内存中所有存活的复制到另一块上。然后将然后再把已使用的内存整个清理掉。

标记-整理算法:复制算法在 GC 之后存活对象较少的情况下效率比较高，但如果存活对象比较多时会执行较多的复制操作，效率就会下降。而老年代的对象在 GC 之后的存活率就比较高，所以就有人提出了“标记-整理算法”。标记-整理算法的“标记“过程与“标记-清除算法”的标记过程一致，但标记之后不会直接清理。而是将所有存活对象都移动到内存的一端。移动结束后直接清理掉剩余部分。

分代回收算法:分代收集是将内存划分成了新生代和老年代。分配的依据是对象的生存周期，或者说经历过的 GC 次数。对象创建时，一般在新生代申请内存，当经历一次 GC 之后如果对还存活，那么对象的年龄 +1。当年龄超过一定值(默认是 15，可以通过参数 -XX:MaxTenuringThreshold 来设定)后，如果对象还存活，那么该对象会进入老年代。

# 什么时候会OOM，OOM怎么排查？（美团）
识别OOM发生的时间和场景，是系统刚启动时，还是在处理大量请求时？是在某个特定的业务逻辑中，还是在某个特定的服务节点上？

查看日志和监控数据。我们要看系统日志和监控数据，jvm在发生OOM时生成一个heapdump，通过分析这个文件找出内存泄漏原因。

分析代码和内存使用情况。比如在使用java集合类时，没有及时调用clear方法，可能导致集合对象一直占用内存。

优化内存管理。我们要对代码进行优化，比如用软引用或弱引用管理不怎么重要的对象，避免占用过多内存。

# 栈中存放什么数据，堆中呢？

栈，存局部变量，方法调用信息，操作数栈，方法返回地址。堆存对象实例，数组。

# ⼤对象放在哪个内存区域？

大对象通常会被分配到堆内存区域。堆内存用于存储所有的对象实例和数组。当对象较大时，它们会在堆中分配较大的空间，并且可能会影响垃圾回收的性能。

# 对象的访问定位的两种⽅式是什么？

句柄方式：对象的引用实际上是一个指向句柄的指针，句柄本身包含了**对象的实际地址**和一些其他信息。

直接指针方式：引用直接指向对象在内存中的位置。句柄相当于\**p才能获得对象实例信息，直接指针\*p即可。

# 为什么需要GC?

因为他自动管理内存，解决了内存泄漏问题，即内存中被占用但无法使用的区域，解决了内存碎片化问题，提高内存使用效率。

# 讲⼀下可达性分析算法的流程。 哪些对象可以作为 GC Roots 呢？

算法流程，定义GC Roots，确定哪些对象可以作为起点。从GC Roots开始遍历，遍历所有直接引用的对象。标记对象，将所有访问过的对象标为可达状态。回收不可达对象，进行垃圾回收。

可以作为GC Root的对象，虚拟机栈的引用，包含线程栈栈帧内的引用。方法区的引用，包含类的静态字段，这些引用代表类加载过程中持有的对象。本地方法栈中的引用，如native方法中持有的引用对象。

# 如何判断对象是否死亡？

引用计数法，为每个对象维护一个引用计数器，记录有多少个引用指向对象，不能处理两个对象相互引用问题。

可达性分析，定义哪些对象可以作为GC Root，从Root进行dfs，不可达的对象进行回收。

# 如何判断⼀个常量是废弃常量?如何判断⼀个类是⽆⽤的类?

如果字符串常量池中的字符串（例如“abc”）**没有任何 String 对象引用它**，这个常量被认为是废弃常量。

无用类的判断条件，如果这个类的所有实例已被回收，他就是无用类。如果加载这个类的classloader已经被回收那么他就是无用类。

# 默认的垃圾回收器是哪⼀个？ZGC 了解吗？

在java8中默认的垃圾回收器是parallelgc，他是个并行收集器。适合多核处理器。在java11中，默认的垃圾回收器变成了g1，他是个分代收集器，提供更高的吞吐量和低延迟，适合大内存场景。

zgc是java11中引入的实验性垃圾回收器，在java15中正式发布，主要特点是**极低的暂停时间**，通常不超过10毫秒，适合低延迟场景。

zgc采用了**颜色指针**和**读屏障**技术，能在不停止应用线程下进行垃圾回收，适合高并发应用。

我的了解。在项目中没有直接用过zgc，但我知道他在高并发场景有很好表现。另外我还了解到，zgc虽然暂停时间短，但在吞吐量上可能不如g1，因此在选择垃圾回收器时，要看具体地场景。

# 讲⼀下 CMS 垃圾收集器的四个步骤

初始标记，暂停应用程序执行，标记所有GC root可达对象。并发标记，CMS与应用程序并发，通过遍历对象图标记可达对象。重新标记，标记在并发标记未捕获的对象。并发清除，CMS与应用程序并发运行，清理对象。

# 并发标记要解决什么问题？并发标记带来了什么问题？如何解决并发扫描时对象消失问题？

并发标记解决GC中应用程序停顿的问题，允许GC程序和应用程序并发执行。问题有对象可能在并发标记汇总被回收，导致遗漏一些对象。解决方法有双重标记法，在并发标记前，使用初始标记创建快照，标记根对象。

# G1 垃圾收集器的步骤

初始标记，标记GC根关联对象。并发标记，与应用程序并发运行，标记所有可达对象。最终标记，标记并发标记期间变化的对象。筛选和清理，回收标记的对象。

# JVM 中的安全点和安全区各代表什么？

安全点是程序执行的特定时刻，所有线程都可以安全暂停下来进行垃圾收集。安全区是在程序执行的代码段内，GC可以安全进行，不用考虑异常问题。

# 堆内存相关的 JVM 参数有哪些？

\-Xms设置jvm堆初始内存堆大小，如-Xms512m设置为512MB，-Xmx设置堆最大大小。

# GC性能指标了解吗 ？调优原则呢？
GC性能指标关注停顿时间和垃圾回收效率。调优原则是降低full gc频率和减少full gc时间。

# 你在项⽬中遇到过 GC 问题吗？怎么分析和解决的？

上线后，发现接口调用频繁导致Young GC频繁告警。Young GC次数增多，同时Old区内存快速升高，最终触发了Full GC。分析发现Guava Cache的Map对象占用大量内存。问题分析：Guava Cache没有设置最大缓存数量，仅设置了过期时间。这导致缓存中存储了大量对象。解决方法，通过为Guava Cache设置最大缓存数量限制，控制缓存中对象的数量，减少内存占用。

# 如何降低 Full GC 的频率？

优化对象创建和生命周期管理。首先尽量减少大对象的创建，因为大对象会直接进入老年代，增加full gc频率。其次，合理管理对象的生命周期，比如使用软引用或弱引用来引用那些生命周期较短的对象。

调整堆的大小。比如适当增加年轻代的大小，这样可以减少对象晋升到老年代的频率，从而降低full gc触发。同时合理设置堆内存的初始大小和最大大小，避免频繁堆内存扩展和收缩。

使用并发标记清除cms或g1收集器。如果系统堆延迟比较敏感，可以考虑用cms或g1，他们都支持并发收集。特别是g1，他将内存划分为多个区域，可以更灵活进行垃圾回收，降低full gc频率。

# 项⽬中实践过 JVM 调优吗？怎么做的？

在公司投放引擎系统中每次发版启动后会进行手动预热，流量切入后，偶尔出现长达2秒的年轻代GC暂停，影响业务。通过GC日志发现每次年轻代GC都会有大量对象晋升，大概600MB。JVM的年轻代GC阶段会根据survivor区的对象总大小动态调整对象晋升年龄阈值，而在启动时，大量新对象在survivor区占据大空间，导致年龄阈值调低为1，意外的晋升到老年代。解决方法，通过调整-XX:**SurvivorRatio**改变Survivor区的大小，如将8改成3，使得survivor占新生代内存的40%，确保容纳大部分对象。修改JVM参数后，再次进行发版和手动预热，年轻代GC暂停花了30毫秒左右，长暂停问题得到解决。

# 网络

# DNS 解析的过程是什么样的（滴滴考过）

递归查询。当用户需要解析一个域名时，首先向本地DNS服务器发送解析请求。如果本地DNS服务器没有缓存结果，它将代表用户向更高层级服务器发起查询，这时更高层级服务器会帮本地服务器递归找到IP地址。迭代查询，也就是非递归查询。本地DNS服务器首先查询根服务器，**根服务器**不返回最终结果，而是告诉本地服务器查询**顶级域服务器**如com，顶级域名服务器再指向具体域名如example.com的**权威DNS服务器**，权威服务器返回最终IP地址给本地服务器，本地返回给用户。

# GET 和 POST 的区别？（字节考过）

GET用于获取查询资源。POST用于创建或修改资源。GET是幂等的而POST是不幂等的。GET请求的参数通常在URL中，而POST请求的参数通常在请求体body中，有多种编码格式，如json等。get请求时幂等的所以可以被浏览器或网关缓存，而POST不适合被缓存。get和post如果用http协议那么都不安全，因为是明文的，要用https。

# 你知道粘包和拆包吗？为什么会发生？怎么解决？（字节考过）
粘包是发送方发送的多个小数据包被接收方一次性接收，导致接收方无法区分这些数据包的边界。
拆包是发送方发送的一个大数据包被接收方分成多次接受，导致接收方无法一次性获取完整数据。
为什么？tcp是流式协议，不保留消息的边界，只保证数据顺序和可靠性。
缓冲区大小，发送方和接收方的缓冲区大小不一致，可能导致数据包被拆分或合并。
nagle算法会延迟小数据包的发送，可能粘包问题。
如何解决？消息定长。发送方和接收方约定每个消息长度固定。
消息分隔符，在每个消息的末尾加上特定的分隔符，接收方根据不同分隔符区分不同的消息。

# 为什么 DNS 协议使⽤ UDP？只使⽤了 UDP 吗？

因UDP不需要TCP那样建立连接，DNS查询通常是小数据包，UDP可以显著减少延迟。但是DNS并不只使用UDP，当DNS响应数据超过512字节时，会使用TCP。

# TCP 是如何保证传输的可靠性？（⾥⾯涉及到的知识点⾮常多，每个都能挖掘不少问题，例如重传机制、流量控制、拥塞控制。如果⽬标是⼤⼚的话，⼀定要吃透，⾯试经常会问的）

确认应答机制。发送方发送数据包后，会等待接收方的确认应答。如果没有收到确认，发送方会重新发送数据包。

序列号和重传机制。tcp为每个数据包分配一个序列号，接收方根据序列号来重组数据包的顺序。如果发送方一定时间内没有收到某个数据包的确认应答，他会认为数据包丢失，并**重新发送数据包**。

流量控制和拥塞控制。tcp使用**滑动窗口**机制进行流量控制，确保发送方发送速率不超过接收方的处理能力。同时，tcp还实现了拥塞控制，通过动态调整发送速率避免网络拥塞。

校验和，tcp在每个数据包中都包含一个校验和，检测数据包在传输过程中是否发生了错误。如果接收方检测到错误，他会丢弃该数据包，并要求发送方重新发送。

# HTTP 报⽂的内容简单说⼀下！ HTTP 请求报⽂和响应报⽂中有哪些数据？

请求报文，包含请求行，请求头部，空行，请求体。请求行包括请求方法、请求目标、和协议版本。响应报文，包含状态行，响应头部，空行，响应体。

# HTTPS 的安全性体现在什么⽅⾯？（本质还是在问 HTTPS 原理）

加密传输。https用ssl tls协议对数据进行加密，确保数据在传输过程中不被窃取。加密过程包括对称加密和非对称加密，对称加密用于实际数据传输，非对称加密用于秘钥交换。

身份验证。https通过**数字证书**验证服务器身份，确保用户连接的是正确的服务器，而不是攻击者。数字证书由**受信任的第三方CA**颁发，客户端会验证证书有效性。

数据完整性。https用**消息认证码**MAC确保数据在传输过程中没有被篡改。通过哈希函数生成MAC，接收方可以验证数据完整性。

防止重放攻击。https通过**序列号和时间戳**防止重放攻击，确保每个请求都是唯一的。

# HTTP/2.0 和 HTTP/3.0 有什么区别？(字节考过)

基础协议。http2是基于tcp协议的，而http3是基于quic协议的，quic协议基于udp，使得http3在连接建立和数据传输时更高效。

连接建立。http2中，建立连接需要经过tcp三次握手。http3通过quic协议，在一个数据包中完成连接建立和加密。

多路复用。http2和http3都支持多路复用，即在一个连接上同时传输多个请求和响应。但是http3通过quic多路复用，可以更好处理网络拥塞和丢包。

头部压缩。http2采用hpack进行头部压缩，http3采用qpack。qpack设计上考虑了quic的特性，可以更高效处理动态表的更新和同步。

# Linux中的epoll和select这些多路复用了解过吗？（腾讯）
多路复用。多路复用允许一个进程同时监视多个文件描述符如网络套接字，并在其中任何一个准备好读取或写入时通知进程。

select系统调用是linux最早的多路复用机制之一。允许我们监视多个文件描述符，等待其中一个准备好进行io操作。select时间复杂度是O n，其中n是文件描述符数量。

epoll是linux内核2.6引入的一种高效多路复用机制。epoll采用事件驱动方式，允许我们注册文件描述符和时间类型，当时间发生时，epoll会通知我们，而不需要遍历所有文件描述符，epoll时间复杂度是O 1。


# HTTPS 加密过程是怎么样的？

1.客户端向服务器发送 HTTPS 请求,

2.服务器将公钥证书发送给客户端。

3.客户端验证服务器的证书。

4.如果验证通过，客户端生成一个用于会话的对称密钥。

5.客户端使用服务器的公钥对对称密钥进行加密，并将加密后的密钥发送给服务器

6.服务器使用私钥对客户端发送的加密密钥进行解密，得到对称密钥。

7.服务器和客户端使用对称密钥进行加密和解密数据传输。

# HTTP/1.0 和 HTTP/1.1 有什么区别？

HTTP1.1采用长连接，以及缓存机制，他们的响应状态码不同，以及1.1带宽更大，host头处理不同。

# HTTP/1.1 和 HTTP/2.0 有什么区别？

2.0采用I/O多路复用，以及二进制帧，头部压缩。

# 什么是 WebSocket?⼀般⽤来做什么？

websocket基于tcp的全双工协议，允许client和server简历持久连接，并且可以实时双向数据传输。一般用来做视频弹幕，实时消息推送以及实时游戏对战。

# WebSocket 和 HTTP 有什么区别？

websocket提供全双工通信，允许client和server同时发送和接受数据。而http是单项请求响应协议。websocket协议前缀是ws，而http就是前缀。websocket的头部信息量小开销比http小。

# WebSocket 的⼯作过程是什么样的？

连接初始化，服务器响应，数据传输，保持链接，连接关闭。初始化阶段client向server发送一个特殊的http请求。server响应阶段他会发送http switching protocols响应。保持连接时可以通过发送心跳包维持回话。关闭连接任一方可以发送一个关闭帧。

# SSE 与 WebSocket 该如何选择？

sse基于标准的http工作，而websocket是独立的协议。sse仅支持单向通信，websocket支持全双工通信。websocket适合需要双向通信应用如在线游戏，而sse适合单向数据流，如推送通知、实时新闻报道。

# PING 命令的作⽤是什么？

用于测试从一个网络设备到另一个设备的连通性。通过icmp回声请求报文实现。他会显式目标主机的域名和IP地址以及rtt。

# PING 命令的⼯作原理是什么

基于icmp协议使用echo Request和echo reply报文实现。

# DNS 是什么？解决了什么问题？

DNS是域名解析系统，解决了域名和IP地址的映射问题。

# DNS 能解析端⼝吗？

不解析，端口号属于传输层的范畴，DNS操作于应用层。

# DNS 服务器有哪些？

DNS有4类服务器，根DNS服务器，顶级域名服务器，权威服务器，本地服务器。根管理顶级域名服务器地址信息，处理对顶级域名服务器的查询请求。顶级域名服务器管理com org net的域名信息。权威服务器管理他负责的域名的DNS记录。本地服务器由ISP维护，作为client和更高级别DNS服务器之间的中介。

# DNS 劫持了解吗？如何应对

DNS劫持通过修改DNS服务器解析结果，使用户访问的域名指向错误的IP地址，从而引导到恶意网站。应对方式有网络层面和应用层面的方法。网络层面使用多个域名，主域名受到攻击使用备用域名，另外可以修改DNS服务器改为更可靠的公共DNS服务。应用层面使用HTTP DNS替代传统的local DNS，通过HTTP协议直接请求专门DNS解析服务，绕过本地ISP DNS服务。

# IP 协议的作⽤是什么？

IP（Internet Protocol，网际协议） 是 TCP/IP 协议中最重要的协议之一，属于网络层的协议，主要作用是定义数据包的格式、对数据包进行路由和寻址，以便它们可以跨网络传播并到达正确的目的地。

# 什么是 IP 地址？IP 寻址如何⼯作？

IP地址是互联网协议地址，有IPv4和ipv6，在网络通信中每个数据包有源IP地址和目的IP地址，他们帮助网络设备正确路由数据包

# IPv4 和 IPv6 有什么区别？

ipv4使用32位地址，已不足以满足全球需求。ipv6使用128位地址，理论上提供了几乎无限的IP地址。另外ipv6不需要NAT来允许多个设备共享一个公共IP地址。

# 操作系统

# 操作系统的调度算法了解吗？

先来先服务算法，最短作业优先算法，高响应比优先算法，高响应比就是说权衡等待时间和要求服务时间，时间片轮转算法。

# 算法

# 写出三种单例模式的实现？你推荐哪⼀种？

枚举类实现。effective Java推荐的方式，无需加锁，线程安全，可以避免 反射破坏枚举单例。静态内部类实现，推荐。单例类的构造方法私有化，并且还有额外的静态内部类有静态最终单例类实例，当getInstance方法调用时，静态内部类才会被加载，单例类才会被初始化。双重校验锁模式。在懒汉式基础上做改进，它的Synchronized没有放在getInstance方法上，而是在if instance==null里面，再锁定当前类，然后再校验instance为null，然后创建对象。

# 加权轮询算法实现

加权轮询算法用于负载均衡。权重越高的服务器越有可能被选中。

# 实现⼀个死锁

Thread t1先获取Synchronized resource1，等待100毫秒，然后获取Synchronized resource2，t2反过来这就产生了死锁。

# ⽣产者和消费者实现

生产者方法while等待队列的size不为满，wait方法，然后生产一个值，执行notify方法。消费者方法while等待队列的size不为空，wait方法，然后消费一个值，执行notify方法。

# 数据结构

# 数组 vs 链表

数组的插入和删除的时间复杂度是O（n），而链表插入删除时间复杂度是O（1）。

# 栈的应⽤场景

表达式求值，以及函数调用的管理，如虚拟机栈。

# 队列的分类、应⽤场景

普通队列，用于广度优先算法。双端队列，用于滑动窗口问题。循环队列用于环形缓冲区。优先队列，用于任务调度如CPU任务调度。

# 红⿊树的特点、红⿊树 vs ⼆叉查找树

红黑树能在log n时间内实现插入删除查找操作，每个节点是红色或黑色，根节点是黑色，红色节点的子节点必须是黑色的，每个节点到所有后代叶子节点的简单路径上包含相同数目的黑色节点，叶子节点都是黑色的空节点。红黑树是一种平衡的二叉查找树，结合了平衡二叉树和二叉查找树的特点。

# 哈希表应⽤场景

哈希表可用于快速查找与缓存，如Memcached以及数据库索引。哈希表用于键值对存储如HashMap。哈希表用于内存地址映射，页表使用哈希表映射虚拟地址到物理内存地址。

# 布隆过滤器应⽤场景

布隆过滤器时一种空间效率极高的概率型数据结构，用于判断一个element是否属于一个集合，但可能错误认为一个不存在的element存在于集合中，假阳性，误判率取决于哈希函数的选择以及位数组的大小，但不会将存在的元素误判为不存在。应用场景有垃圾邮件过滤，以及缓存系统中的热点数据识别，避免频繁访问MySQL。

。