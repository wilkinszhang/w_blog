# 算法题

# 1 数组中第K个最大元素 给你数组nums和整数k，请返回数组中第k个最大的元素。

思路，用快速选择算法。步骤，先选择一个枢轴，从数组中选择一个元素作为枢轴。将数组分成两个部分，一部分是比枢轴大的元素，另一部分是比枢轴小的元素。根据k的值和枢轴的位置决定下一步在哪部分递归搜索。

# 2 无重复字符的最长子串 给你一个字符串s，请找出其中不含有重复字符的最长子串的长度。子串是连续的。

思路，用滑动窗口。用set记录当前窗口中的字符，用left和right维护窗口，当right指向的是重复字符时，删除left对应元素，并移动left指针缩小窗口，直到没有重复字符。while的条件是right小于字符串长度，遍历每个可能的right。

# 3 lru缓存 请你实现lru cache类，以正整数capacity初始化lru缓存，get方法，如果关键字key存在于缓存中，则返回关键字值，否则返回-1。put方法如果key已经存在则覆盖值value。如果不存在，则向缓存中插入key value。如果缓存已满，则应**逐出**最久未使用的关键字。get和put必须以O 1 时间运行。

思路，用哈希表和双向链表实现。哈希表用于快速查找，双向链表用于维护元素使用顺序。双向链表有辅助方法，addToHead将节点添加到链表头部，removeNode从链表移除节点，moveToHead将节点移动到链表头部，popTail移除并返回链表尾部节点。

get方法查找键值，如果存在则移动节点到链表头部moveToHead并返回值，否则返回-1。put方法如果健存在则更新值并移动到链表头部moveToHead，如果键不存在则插入新节点addToHead，并在超过容量时，删除尾部节点popTail。

# 31 环形链表II 给你一个链表头结点head，返回链表开始入环的第一个节点，如果无环，则返回null。

思路，用双指针法。初始化快慢指针，都指向头结点head。slow每次移动一步，fast每次移动两步，如果链表中有环，那么slow会追上fast，当相遇时，再将slow拿到head，然后slow和fast每次移动一步，当他们再相遇时，所在的节点就是环的入口。
证明：设头结点到环的入口点距离为a，环入口点到相遇点距离为x，环长为r，相遇时fast绕了n圈，则有2乘以a加上x等于a加n乘以r加上x，也就是a等于n乘以r减去x，所以如果fast从相遇点移动，那么他们会在环入口点相遇。

# 32 合并区间 给你数组intervals表示若干个区间的集合，其中一个区间为start end，请你合并所有重叠的区间，并返回一个不重叠的区间数组。

思路，按照起始位置排序，然后遍历并合并区间。首先将所有区间按照起始位置升序排序，然后初始化一个空列表存放合并后的区间结果。对于每一个区间，如果他与结果列表中的最后一个区间重叠，也就是当前区间的起始位置小于等于最后一个区间的结束位置，则将他们合并，取两个区间结束位置最大值作为合并区间后的结束位置。如果不重叠，直接将当前区间添加到结果列表。

# 33 二叉树中的最大路径和 二叉树中的路径被定义为一条节点序列，序列中每对相邻节点之间都存在一条边，该路径至少包含一个节点，且不一定经过根节点。路径和事路径中各节点值的总和，给你二叉树根节点root，返回其最大路径和。

思路，递归，对于每个节点，计算该节点的最大路径和，三种情况，仅包含当前节点，包含当前节点和左子树最大路径，包含当前节点和右子树最大路径。 对于每个节点，我们也要计算如果该路径作为一条从父节点传入路径一部分，它的最大贡献，就是节点值加上左右子树较大路径的值。 注意，在当前节点为null时，返回0，而在队规计算左右子树最大路径时，只能取正值，和0之间去最大值。

# 34 编辑距离 给你两个单词word1和word2，请返回word1转化成word2所需的最少操作数。有三种操作，插入一个字符，删除一个字符，替换一个字符。

思路，动态规划。dp i j表示从word1前i个字符串到word2前j个字符串所需的最少操作数。状态转移方程如下：如果当前两个字符相同，则不需要额外操作，dp i j为dp i-1 j-1。
如果当前两个字符不同，考虑三种操作，插入一个字符到word1，dp i j为dp i j-1 加一。从word1删除一个字符，dp i j为dp i-1 j加一。替换当前字符，dp i j为dp i-1 j-1加一。最后dp 最后一行最后一列元素就是将word1转化到word2所需最少操作数。

# 35 删除链表的倒数第N个节点 给你一个链表，删除链表的倒数第n个节点，返回链表头结点

思路，用双指针。先创建一个哨兵dummy，指向head，初始化fast和slow，都指向dummy，将fast向前移动n步，这样fast和slow就有n个节点的距离。同时移动fast和slow，直到fast为空，此时slow指向倒数第n-1个节点，如果slow这时指向dummy，那么把dummy的next指向slow的下一个节点，对应要删除的是头结点的情况。

# 36 复原IP地址 给你一个只包含数字的字符串s，表示一个IP地址，返回所有可能的有效IP地址，这些地址可通过在s中插入点号完成。

思路，用递归。参数有String s，start当前所在字符位置，partcount第几位，StringBuilder当前的结果，以及result列表。递归的出口是partcount为4且start到达串末尾。然后遍历当前位可以有1到3个字符，取出这个子串，判断是否有效，有效则进行递归，把StringBuilder加上当前子串。

# 37 最长公共子序列 给你两个字符串text1和text2，返回这两个字符串的最长 公共子序列的长度。如果不存在公共子序列返回0。子序列可以不连续。

思路，用动态规划。创建dp i j表示text1前i个字符和text2前j个字符的最长公共子序列的长度。dp 0 j和dp i 0都初始化为0，因为任何字符串与空串的LCS长度为0。如果text1 i-1与text2 j-1相等，则dp i j为dp i-1 j-1加一。否则dp i j取dp i-1 j和dp i j-1的最大值。

总结，公共子串，要求字符连续，动态规划转移方程只在字符匹配时更新，字符不匹配时重置为0.子数组和子串一样，也要求连续。

# 38 二叉树中序遍历 给你一个二叉树根节点返回中序遍历

思路，和后面的前序遍历差不多，用栈模拟遍历过程，current变量记录当前节点，while条件是current不为空且stack非空。内层while循环当current不为空时，往栈里面丢元素。然后从栈顶取节点作为current，把current放入list结果里面，然后把current指向current的right。

# 39 删除链表中的重复元素II 给定一个已排序的链表的头head，删除原始链表中所有重复数字的节点，只留下不同的数字，返回链表头结点。

思路，用两个指针跟踪当前节点和下一个节点。步骤，创建一个虚拟头结点dummy，next指向head。使用prev和current指针。prev指向当前非重复节点前一个节点，current指向当前节点。遍历链表，检查当前节点是否重复的， 如果重复跳过所有重复节点，跳出循环后将prev的next指向current的next，也就是prev的next指向下一个不同的节点。如果当前节点不是重复的，把prev更新为prev的next。最后更新current为current的next。返回dummy的next。

# 51 滑动窗口最大值 困难题 给你一个整数数组nums，有一个大小为k的滑动窗口从数组最左侧移动到数组最右侧，你只可以看到滑动窗口内的k个数字，每次向右移动一位，返回滑动窗口中的最大值。

思路，用双端队列deque实现，用双端队列存储窗口内的潜在最大值索引，从而在每次滑动窗口时快速找到最大值。步骤，初始化双端队列，保证从队列前端到后端，元素对应数组值是递减的，遍历数组，移除旧的元素，检查队列前端，如果队列中存储的元素索引已不在滑动窗口中，则从队列前端移除。 在添加新element之前，从队列后端开始，移除所有比当前元素小的元素的索引，确保队列前端始终是当前窗口中的最大值。 将当前element的索引添加到队列后端。 当窗口的长度首次达到k时开始记录，每次移动窗口时，队列的前端element就是当前窗口的最大值。

# 52 比较版本号 给你两个版本号字符串，version1和version2，请你比较他们，版本号由英文点 分隔开的修订号组成，修订号的值是 它转化为整数并忽略前导0。 比较版本号时，从左到右比较修订号，如果其中一个修订号较少，缺失的修订号视为0。如果version1小于version2返回-1，如果大于返回1，相等返回0.

思路，使用String split方法将版本号分割成修订号数组。如果某个版本号较短并且当前位置没有版本号，手动在末尾添加0。 遍历修订号数组，直到发现不相等的位置或者全部遍历完成。

# 53 缺失的第一个正数 困难题 给你一个未排序的整数数组nums，找出其中没有出现的最小的正整数。时间要求 O n，空间要求 O 1。

思路，用 原地哈希 实现，用数组本身作为哈希表，将每个数字尝试放在其应有的位置上，即数字1 放在索引0的位置，数字2放在索引1的位置。这种方法通过交换元素逐步将数组整理成接近有序的状态，通过索引判断缺失的最小正整数。步骤，预处理，遍历数组，将所有小于等于0的数字改为N+1，消除负数和零的干扰。 原地哈希，再次遍历数组，对于每个数字，如果其值在1到N范围内，将其放在正确的位置，如果目标位置已经有正确数字，则不需要交换，注意交换操作在一个while循环内，可能交换之后仍然不满足条件。 最后遍历数组，检查每个位置i是否包含数字i+1，第一个不符合条件的位置就是缺失的最小正整数。

# 54 零钱兑换 给你一个整数数组coins，表示不同面额的硬币以及一个整数amount，表示总金额，计算并返回可以凑成amount所需的 最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回-1，你可以认为每种硬币数量无限。

思路，动态规划，dp i代表凑成金额i所需的最少硬币数量。步骤，初始化dp数组，创建一个大小为amount+1的数组，初始值设为amount加一，代表所需硬币数无限大，dp 0为0，金额为0不需要任何硬币。  状态转移，对于每个金额 i 从1到amount，对每个硬币coin，如果coin小于等于i，则更新dp x为 dp x减coin   再加一。 返回结果如果dp amount没有更新则返回-1，否则返回dp amount。

# 55 训练计划II 给你一个头结点为head的链表，查找并返回倒数第cnt个节点。

思路，用双指针。初始化两个指针slow和fast，都指向head，移动fast指针，先让fast指针向前移动cnt步，这样fast和slow会保持cnt步的距离。 同时移动fast和slow指针，直到fast到达末尾，这时slow指针指向链表中倒数第cnt个节点。

# 56 最小覆盖字符串 困难题 TODO

# 57 子集 给你一个整数数组nums，数组中元素互不相同，返回数组中所有可能的子集。

思路，用回溯法，从空集开始，逐步添加数组中每个元素，生成所有可能的子集，每个元素可以选择加入当前子集或者不加入。

# 58 从前序与中序遍历序列构造二叉树 给你两个整数数组preorder和inorder，请构造二叉树并返回其根节点。

思路，用递归和哈希表构造树。用index记录当前处理前序遍历的元素索引，map存储中序遍历数组每个元素值和对应的索引的哈希表，用于快速定位根节点。  递归参数，preorder数组，left，right。步骤，如果left大于right，表示子数组没有元素，返回null。选择当前index指向的值作为根节点，递增index，使用map查找当前根节点在中序遍历中的索引，递归构建左子树，使用中序遍历左边部分，递归构建右子树，使用中序遍历右半部分。

# 59 最长有效括号 困难题 给你一个只包含左括号和右括号的字符串，找出最长连续有效括号子串的长度。

思路，用栈跟踪未匹配的括号的 索引。创建一个栈，将-1压入栈中，帮助处理第一个括号匹配的情况。 然后遍历字符串，如果是左括号，将索引压入栈。
如果是右括号，先弹出栈顶元素，对应最近一个未匹配的左括号。然后判断栈如果为空，将当前字符索引入栈，这表示之前所有括号都匹配完毕，而当前的右括号没有找到匹配。
判断栈不为空，则计算有效子串长度，当前索引减去栈顶元素，因为栈顶元素下一个索引到当前索引之间的子串是有效的。难点是用栈保存索引以及碰到右括号该怎么处理。

# 60 字符串相乘 给你两个以字符串形式表示的非负整数num1和num2，返回num1和num2的乘积，他们的乘积也表示为字符串形式。不能用BigInteger库。

思路，暴力法。创建一个数组result，长度为num1和num2长度之和。反转num1和num2，保存到StringBuilder里面，然后遍历两个字符串每一位，将他们相乘，并加到result数组i+j位置上，然后处理进位，把对10取余的结果保存在result i+j位置上，把除以10的结果保存在result i+j+1位置上。 遍历完成后，从后往前遍历result数组，去掉前导零，然后再把他丢到StringBuilder里面，返回toString。

# 61 最小栈 设计一个支持push pop top操作，并能在常数时间检索到最小元素的栈。

思路，用两个栈，主栈和最小栈，元素入栈时如果最小栈为空或者元素值 小于或等于 最小栈的栈顶，那么压入最小栈。元素出栈时，如果最小栈非空并且最小栈的栈顶大于或等于主栈的栈顶，那么要先出栈最小栈，然后才出主栈。这里的push和pop都有个兜底的逻辑。

# 62 反转字符串中的单词 给你一个字符串s，反转字符串中单词的顺序，注意字符串可能存在前导空格，尾随空格或者单词之间有多个空格。

思路，先用trim方法去除收尾空白，然后用split方法以及反斜杠反斜杠s加正则表达式根据一个或多个空格分割字符串为单词数组，然后用Collections.reverse方法反转数组列表，最后使用String join方法将反转后单词数组重新组合成一个字符串，单词之间以一个空格分隔。

# 63 从根节点到叶节点数字之和 每条从根节点到叶节点的路径代表一个数字，如1 2 3 路径代表数字123。

思路，用dfs，参数为当前节点root，当前总和current sum int数组，保存路径对应的数字的列表list，访问一个节点，把current sum乘以10，把当前节点值加到current sum上，然后递归遍历左右子节点，然后复原current sum。把列表里面所有element相加就是答案。

# 64 对称二叉树 给你一个二叉树的根节点root，检查他是否轴对称。轴对称的概念不是递归的，只能说这个书是轴对称的，不能说左右子树是对称的。

思路，用dfs，参数为左子树left，右子树right，如果两个子树满足他们的根节点值相等，并且左子树的左子树和右子树的右子树是对称的，并且左子树的右子树和右子树的左子树是对称的。

# 65 二叉树的前序遍历 

思路，dfs就是先加到list，再访问左右子树。非递归用栈模拟递归，并用一个current变量存储当前节点root，while循环条件是current或栈不为空，然后内层又有一个while，只要current不为空，往栈，列表list添加current，current不停向left子树移动，然后跳出后取栈顶，current指向栈顶的right子树。

# 67 平衡二叉树 给你一个二叉树，判断他是否是平衡二叉树

思路，dfs，先写一个获得当前子树高度的方法getDepth，然后先判断当前节点root是否平衡，通过判断左右子树高度差是否小于等于1，然后再递归判断左右子树是否平衡。

# 68 组合总和 给你一个无重复元素的整数数组candidates和一个目标整数target，找出candidates中可以使数字和为target的所有不同组合，并以列表形式返回。candidates中同一个数字可以无限制重复被选取。

思路，回溯法，参数为当前列表current，当前和cursum，当前索引index，candidates数组，以及result列表。从当前索引index遍历candidates数组，将当前element加入current，并减少cursum，然后递归调用自己尝试找到有效组合。然后把这个element从current中移除撤销选择，并把cursum加上element，以尝试下一个可能的组合。

# 69 二叉树直径 给你一个二叉树，返回该树的直径，直径是指树中任意两个节点之间最长路径的长度，路径可能不经过根节点root。

思路，dfs，参数为根节点root，结果result，递归计算每个节点左右子树高度，对于每个节点，经过这个节点的最长路径长度通过左子树高度加上右子树高度计算，然后更新全局最大路径长度result，然后递归return当前节点的高度，也就是左右子树高度的较大者加一。

# 70 在排序数组中查找元素的第一个和最后一个位置

思路，二分查找，先找到第一个位置，找到一个等于target的element时，向左移动右指针right缩小查找范围，当mid-1的element的值不为target时，mid就是第一个位置。    查找最后一个位置，重复上面的二分查找步骤，但在找到等于target的element时，向右移动左指针left，确定最后一个等于target的位置。

# 71 用rand7实现rand10

思路，先生成更大的范围，(rand7-1)*7 + rand7生成1到49的随机数，将rand7的结果视为两位七进制数，其中第1位乘以7。然后拒绝41到49的结果，拿到1到40的结果，用 (result-1) % 10 + 1来映射到1到10的范围。

# 72 旋转图像 给定nn矩阵，将矩阵顺时针旋转90度

思路，先将矩阵转置，行列互换，再把每一行的element反转。

# 73 验证二叉搜索树，看二叉搜索树是否有效，有效是指节点左子树只包含 小于 当前节点的树，右子树只包含大于的，左子树和右子树也必须是二叉搜索树。

思路，dfs传递当前节点值的有效范围最小值，最大值，每次递归调用时，更新节点值应该在的范围。

# 74 最小路径和 给定mn网格，找出从左上到右下最小的路径，只能向右或向下走。

思路，动态规划，dp i j代表到达i j的最小路径和，第一行第一列直接累加，其他情况，dp i j等于左方和上方的dp最小值加上当前单元格的值。

# 75 字符串解码。给定一个编码过的字符串，返回解码后的字符串，编码规则是k 中括号 string 中括号，string重复k次，可以认为原始数据不包含数字。

思路，用栈处理，遍历整个字符串，用两个栈，一个存储重复次数，一个存储在每个重复次数之前的字符串部分。还有两个变量，当前重复次数和当前字符串。遇到数字时，算出完整的重复字数，可能有多位，遇到左括号时，将当前重复次数和当前字符串推入栈，并重置次数和字符串。遇到右括号时，从栈中弹出重复次数和之前的字符串，将当前字符串重复相应次数，并拼接到弹出的字符串后面，注意，是拼接到弹出的字符串后面。遇到字母时，加到当前字符串。

# 76 最大正方形 在一个由0和1组成的二维矩阵内，找到只包含1的最大正方形，返回其面积。

思路，动态规划，用二维数组dp存储以 i j为右下角的最大正方形的边长。对于矩阵每个element，如果他是1检查它的上方，左方和左上方的dp值，这三个值的最小值加一就是dp i j的值。如果i j元素的值是0，那么dp i j就是0。

# 77 路径总和 II 给你二叉树根节点root和一个整数目标target，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径

思路，用dfs，参数有result列表，current列表，target int数组，先将当前节点值加到current列表，并把target减去当前节点值，然后如果当前节点已经是叶子结点，左右孩子都为null，那么判断一下target是不是0，是0则把current列表加到result里面，然后递归遍历左节点，右节点，完成探索后，把当前节点的值从current列表中移除，并把target加回当前节点值。

# 78 搜索二维矩阵 II

思路，借鉴二维版本的二分查找思想。从矩阵右上角开始，设置当前位置为 i j，如果当前i j的值等于target，返回true，如果大于target，说明target不能在当前元素右边，因此j--，向左移动，如果小于target，说明target不能在当前元素上边，因此i++，向下移动。如果i j超出边界，则返回false。

# 79 寻找峰值 给你一个nums数组，找到峰值并返回其索引，峰值是严格大于左右相邻。数组可能包含多个峰值，返回任意一个。时间要求 log n。

思路，二分查找，left为0，right为nums的length减一，然后while二分查找，计算中点mid，检查nums mid是否大于其相邻元素，如果nums mid 比 nums mid+1 要大，那么mid左侧必存在一个峰值，right更新为mid。否则峰值在mid+1右侧，将left更新为mid+1。返回left。

# 80 最长公共前缀 写一个函数找字符串数组中最长公共前缀，如果不存在返回空字符串。

思路，蛮力法。选择第一个字符串作为基准字符串，对于数组中剩下每个字符串，用indexOf方法检查基准是否是该字符串前缀，如果不是，则逐步缩短前缀，就是用substring去掉最后一个字符，直到找到一个公共前缀或者前缀为空。

# 81 最长连续序列 给定一个未排序nums数组，找出数字连续的最长序列长度，这个序列不需要再原数组中连续，时间要求 O n。

思路，用哈希表解决。先将所有元素加到HashSet中。遍历数组中每一个数字，判断这个数字是否是某个连续序列的起点。一个数字时起点的条件是这个数字前一个数字nums i 减一不在集合中，这一点是关键。如果条件满足，那么他是新序列起点。然后我们循环检查是否存在nums i 加一加二等，然后更新最大长度。

# 82 回文链表 给你一个单链表头结点head，判断该链表是否为回文链表，是则返回true，否则返回false。

思路，先找到链表中间节点，使用快慢指针，当快指针到链表尾时，慢指针在后半链表的起始节点位置。然后翻转链表后半部分，原地翻转，使用头插法。然后比较两部分链表，如果所有对应位置节点值都相等，则返回true。

# 84 二叉树最大宽度 给你二叉树根节点root，返回树的最大宽度，最大宽度是所有层最大的宽度

思路，用层序遍历，广度优先，根节点索引是0，左节点索引是2 i +1，右节点是 2 i +2，初始化两个队列双端队列q1，q2，把根节点加入q1，遍历q1中每个element，如果element存在左右子节点，都加入q2，当q1为空时，把q1赋值为q2，并新建一个q2，然后再判断q1是不是空，不是空我们拿出队列头和尾，更新最大宽度。

# 85 多数元素 给你一个nums数组，返回其中的多数元素，多数元素是指出现次数大于二分之n的元素

思路，用投票算法。原理是多数元素出现频率高于所有其他元素总和，因此即使其他元素与多数元素相抵消，最后剩下的一定是多数元素。步骤，初始化两个变量，result和count，result取值为第一个element，count取值为0，遍历数组中每个元素x，如果count为0，，将result设置为x并将count设为1。如果count不为0，若x等于result则count增加1，否则count减少1。通过上面步骤，result就是多数元素。

# 86 最大数 给你一组非负整数数组nums，重新排列每个数顺序使它成为一个最大整数

思路，自定义排序，new Comparator自定义compare方法，比较字符串o1+o2和o2+o1的大小，决定o1 o2谁在前面。

# 87 最长重复子数组 给你两个数组nums1和nums2，返回两个数组中公共长度最长的子数组的长度。子数组是连续的。

思路，动态规划，定义二维dp，dp i j表示以nums i和nums j结尾的最长公共子数组长度，如果nums i 和nums j相等，则dp i j是dp i-1 j-1 加一

# 88 删除链表中重复元素

思路，判断当前element和后继值是否相同，相同则跳过后继，即当前element的next指向下下个element。

# 89 基本计算器 II

思路，用一个数字栈，一个字符变量记录最后的操作符，一个变量保存当前数字。如果遇到数字解析整个数字，注意可能有多位。如果遇到一个操作符或者达到字符串结尾，根据前一个操作符更新栈，如果操作符是加减，前一个数字直接入栈，如果操作符是乘除，弹出栈顶与当前数字运算，推回栈中。最后，把栈中所有元素相加。注：坑点是在判断当前字符是数字还是操作符时，不能用if else if而是两个if。

# 90 不同路径 mn网格机器人从左上角走到右下角有多少不同路径

思路，动态规划，ij的路径由i-1 j和i j-1转移，第一行和第一列的值都是1。


