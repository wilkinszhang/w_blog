# 算法题

# 70 在排序数组中查找元素的第一个和最后一个位置

思路，二分查找，先找到第一个位置，找到一个等于target的element时，向左移动右指针right缩小查找范围，当mid-1的element的值不为target时，mid就是第一个位置。    查找最后一个位置，重复上面的二分查找步骤，但在找到等于target的element时，向右移动左指针left，确定最后一个等于target的位置。

# 71 用rand7实现rand10

思路，先生成更大的范围，(rand7-1)*7 + rand7生成1到49的随机数，将rand7的结果视为两位七进制数，其中第1位乘以7。然后拒绝41到49的结果，拿到1到40的结果，用 (result-1) % 10 + 1来映射到1到10的范围。

# 72 旋转图像 给定nn矩阵，将矩阵顺时针旋转90度

思路，先将矩阵转置，行列互换，再把每一行的element反转。

# 73 验证二叉搜索树，看二叉搜索树是否有效，有效是指节点左子树只包含 小于 当前节点的树，右子树只包含大于的，左子树和右子树也必须是二叉搜索树。

思路，dfs传递当前节点值的有效范围最小值，最大值，每次递归调用时，更新节点值应该在的范围。

# 74 最小路径和 给定mn网格，找出从左上到右下最小的路径，只能向右或向下走。

思路，动态规划，dp i j代表到达i j的最小路径和，第一行第一列直接累加，其他情况，dp i j等于左方和上方的dp最小值加上当前单元格的值。

# 75 字符串解码。给定一个编码过的字符串，返回解码后的字符串，编码规则是k 中括号 string 中括号，string重复k次，可以认为原始数据不包含数字。

思路，用栈处理，遍历整个字符串，用两个栈，一个存储重复次数，一个存储在每个重复次数之前的字符串部分。还有两个变量，当前重复次数和当前字符串。遇到数字时，算出完整的重复字数，可能有多位，遇到左括号时，将当前重复次数和当前字符串推入栈，并重置次数和字符串。遇到右括号时，从栈中弹出重复次数和之前的字符串，将当前字符串重复相应次数，并拼接到弹出的字符串后面，注意，是拼接到弹出的字符串后面。遇到字母时，加到当前字符串。

# 76 最大正方形 在一个由0和1组成的二维矩阵内，找到只包含1的最大正方形，返回其面积。

思路，动态规划，用二维数组dp存储以 i j为右下角的最大正方形的边长。对于矩阵每个element，如果他是1检查它的上方，左方和左上方的dp值，这三个值的最小值加一就是dp i j的值。如果i j元素的值是0，那么dp i j就是0。

# 77 路径总和 II 给你二叉树根节点root和一个整数目标target，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径

思路，用dfs，参数有result列表，current列表，target int数组，先将当前节点值加到current列表，并把target减去当前节点值，然后如果当前节点已经是叶子结点，左右孩子都为null，那么判断一下target是不是0，是0则把current列表加到result里面，然后递归遍历左节点，右节点，完成探索后，把当前节点的值从current列表中移除，并把target加回当前节点值。

# 78 搜索二维矩阵 II

思路，借鉴二维版本的二分查找思想。从矩阵右上角开始，设置当前位置为 i j，如果当前i j的值等于target，返回true，如果大于target，说明target不能在当前元素右边，因此j--，向左移动，如果小于target，说明target不能在当前元素上边，因此i++，向下移动。如果i j超出边界，则返回false。

# 79 寻找峰值 给你一个nums数组，找到峰值并返回其索引，峰值是严格大于左右相邻。数组可能包含多个峰值，返回任意一个。时间要求 log n。

思路，二分查找，left为0，right为nums的length减一，然后while二分查找，计算中点mid，检查nums mid是否大于其相邻元素，如果nums mid 比 nums mid+1 要大，那么mid左侧必存在一个峰值，right更新为mid。否则峰值在mid+1右侧，将left更新为mid+1。返回left。

# 80 最长公共前缀 写一个函数找字符串数组中最长公共前缀，如果不存在返回空字符串。

思路，蛮力法。选择第一个字符串作为基准字符串，对于数组中剩下每个字符串，用indexOf方法检查基准是否是该字符串前缀，如果不是，则逐步缩短前缀，就是用substring去掉最后一个字符，直到找到一个公共前缀或者前缀为空。

# 81 最长连续序列 给定一个未排序nums数组，找出数字连续的最长序列长度，这个序列不需要再原数组中连续，时间要求 O n。

思路，用哈希表解决。先将所有元素加到HashSet中。遍历数组中每一个数字，判断这个数字是否是某个连续序列的起点。一个数字时起点的条件是这个数字前一个数字nums i 减一不在集合中，这一点是关键。如果条件满足，那么他是新序列起点。然后我们循环检查是否存在nums i 加一加二等，然后更新最大长度。

# 82 回文链表 给你一个单链表头结点head，判断该链表是否为回文链表，是则返回true，否则返回false。

思路，先找到链表中间节点，使用快慢指针，当快指针到链表尾时，慢指针在后半链表的起始节点位置。然后翻转链表后半部分，原地翻转，使用头插法。然后比较两部分链表，如果所有对应位置节点值都相等，则返回true。

# 84 二叉树最大宽度 给你二叉树根节点root，返回树的最大宽度，最大宽度是所有层最大的宽度

思路，用层序遍历，广度优先，根节点索引是0，左节点索引是2 i +1，右节点是 2 i +2，初始化两个队列双端队列q1，q2，把根节点加入q1，遍历q1中每个element，如果element存在左右子节点，都加入q2，当q1为空时，把q1赋值为q2，并新建一个q2，然后再判断q1是不是空，不是空我们拿出队列头和尾，更新最大宽度。

# 85 多数元素 给你一个nums数组，返回其中的多数元素，多数元素是指出现次数大于二分之n的元素

思路，用投票算法。原理是多数元素出现频率高于所有其他元素总和，因此即使其他元素与多数元素相抵消，最后剩下的一定是多数元素。步骤，初始化两个变量，result和count，result取值为第一个element，count取值为0，遍历数组中每个元素x，如果count为0，，将result设置为x并将count设为1。如果count不为0，若x等于result则count增加1，否则count减少1。通过上面步骤，result就是多数元素。

# 86 最大数 给你一组非负整数数组nums，重新排列每个数顺序使它成为一个最大整数

思路，自定义排序，new Comparator自定义compare方法，比较字符串o1+o2和o2+o1的大小，决定o1 o2谁在前面。

# 87 最长重复子数组 给你两个数组nums1和nums2，返回两个数组中公共长度最长的子数组的长度。子数组是连续的。

思路，动态规划，定义二维dp，dp i j表示以nums i和nums j结尾的最长公共子数组长度，如果nums i 和nums j相等，则dp i j是dp i-1 j-1 加一

# 88 删除链表中重复元素

思路，判断当前element和后继值是否相同，相同则跳过后继，即当前element的next指向下下个element。

# 89 基本计算器 II

思路，用一个数字栈，一个字符变量记录最后的操作符，一个变量保存当前数字。如果遇到数字解析整个数字，注意可能有多位。如果遇到一个操作符或者达到字符串结尾，根据前一个操作符更新栈，如果操作符是加减，前一个数字直接入栈，如果操作符是乘除，弹出栈顶与当前数字运算，推回栈中。最后，把栈中所有元素相加。注：坑点是在判断当前字符是数字还是操作符时，不能用if else if而是两个if。

# 90 不同路径 mn网格机器人从左上角走到右下角有多少不同路径

思路，动态规划，ij的路径由i-1 j和i j-1转移，第一行和第一列的值都是1。


